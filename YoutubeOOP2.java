package youtubeoop2;
public class YoutubeOOP2 {
  
    public static void main(String[] args) {
        //35 again this lecture
        
             //welcome from OOP.....
             //ملاحظة
             //بنفع اعمل كلاس وتحته كلاس اخر ممكن يكون وارث من كلاس معين
             //ولكن ما تكون كلمة public مسنودة اله
             //لانه ايا كلاس public لازم يكون بملف لحاله
             
             
             /*
             اختصار السيت والجيت
             كليك يمين انسيرت كود 
             كونستراكتور
             او ستر وجيتر 
             او ميثود توسترينج
             
             
             وظيفة ذيس انها تعمل اكسس لكل الداتا ميمبر
             فالكلاس
             */
             
             //مفهوم Encapsulation (private)==التغليف
             /*
             بنطلق على الكلاس اللي بنطبق عليه هذا المفهوم tightly encapulated
             بكون كل الاتربيوت فيه عبارة عن برايفت ومعموللها السيتر والجيتر
             */
             //اني بقدر اوصل لدالة او متغير معين عن طريق السيتر والجيتر
             //اشهر الميثود للاوبجكت
             //setName..()
             //get()
             
             //بعمل الكلاس اللي فيه دالة السيت والجيت بدون المين
             //الكلاس اللي فيه المين او دالة المين تحت الكلاس اللي انشأناه بكون للتنفيذ اي بننشئ فيه اوبجكت
             //دالة المين بنحطها بنفس الكلاس عادي ازا بدنا بس الست والجيت ما بنحطها فيها
             
             //31
             //Classes and Objects
             
             //قواعد تسمية الاوبجكت نفس قواعد تسمية الفاريبل
             //obj == اي شئ بحاجة اني اخد عنه بيانات واحفظها بقاعدة البيانات
             //يتكون من === Variables + methods
             
             //لما ننشئ اوبجكت
             //كلمة نيو تعني مساحة مخصصة لايش للكلاس نفسه 
             //عشان هيك بكتب اسم الكلاس جنب نيو
             
             //ممكن اعطي اسم للمتغير النيم فالكلاس
             // obj1.name="noura";
             //واطبعه من خلال جملة الطباعة بكتابة هذا الاوبجكت//S.o.p(obj1.name);//noura
             //واطبعه من خلال دالة الجيت
             
             /*
             كان استخدمنا هاي الطريقة وخلص ليش استخدمنا سيت وجيت
             استخدمناهم لو بدنا نحط شرط معين على الاوبجكت
             بدنا نعدل على كل الاوبجكت ونروح نكتب هذا الشرط بكل اوبجكت يعني صعب
             فبنحط هذا الشرط بنكتبه مرة وحدة داخل السيت والجيت وبنصير نستخدمها
             فكل اوبجكت بسهولة
             */
             
             //احنا بنعمل عدة اوبجكت من كلاس واحد
             //كل الاوبجكت الهم نفس الارتبيوس والاوبريشن
             //الاختلاف في داتا فاليو
             //لازم يكونوا مختلفين عن بعض
             
             
             //Access level modifiers
             //public -  accessed from any class.//بقدر استخدم البيانات او الميثود داخل اي كلاس في المشروع
             //private - accessed within the class.//وين البيانات معرفة فقط بقدر استخدمها داخل الكلاس
             //defult or pcaje private//زي لما ما نكتب اشي جنب البيانات بنقدر نستخدمها داخل الباكج فقط
             /*
                بنقدر نعدل على البيانات مباشرة داخل اي كلاس وهذا مش محبذ
              عشان هيك بنكتب برايفت جنب البيانات عشان اقدر استخدمها داخل الكلاس الموجودة فيه وبس  
             اما التعديل بكون من خلال الميثود ست مثلا   
             */
             
             //protected-within the class and by classes derived from that class.
             
             //هذا التكنيك اسمه
             //data hideng
             //انه ما بنقدر نوصل للبيانات الا من خلال ميثود
             
             //تقريبا هذا موضوع
             //Encapsulation التغليف
             
             
             
            //33
            //Constructor...
            //هو طريقة لإنشاء كائن جديد بنموذج أولي محدد
            
            
            //فائدته انه يعطي انيشيال فاليو للفيلد اي الحقول
            //حتى لو انت ما عبيتهم بايدك
            
            //مثلا فتطبيق بدي اعمل حساب لشخص
            //هاي الواجهة ااسمها اوبجكت اللي فيها مجموعة من الفيلدز بتطلب تسجيل معلومات
            //هاي الواجهة بنسميها اوبجكت
            //وفي حقول فيها انيشال فاليو  قلنا انها كونستراكتور
            
            
            //اسمه نفس اسم الكلاس
            //ما اله ريتيرن تايب معين ولا حتى بنستخدم اسم فويد
            //مستحيل يكون ابستراك او ستاتيك او فاينل او سينكرايزين
            
            
            //مثال //no-arg constructor
            //لما ننشئ كونستراكتور //انشئناه بدون براميتار
            //بكتب فيه القيم الابتدائية للمتغيرات
            //ثم من خلال دالة بنطبع هاي المتغيرات
            //فلما انشئ اوبجكت واطبع دالة الطباعة من خلاله بعطيني القيم الابتدائية للمتغيرات
            /*
            او بدون ما انشئ هذا الكونستراكاتر هو بكون باي ديفولت مع الاوبجكت اللي انا بنشئه
            */
            
            //طيب لو بدنا نغير ع القيم من خلال انه المستخدم يحط قيم فالخانات
            //بنعمل سيت للمتغيرات
            
            //او بنعمل كونستراكتور بداخله براميتر
            //اوفر لودينق
            //انه يكون في دالة نفس الاسم
            //لكن موجودة باكثر من مكان بنفس البرنامج
            
            //بنعمل كمان كونستراكتور مع براميتر
            
            //واي اوبجكت انا يستخدمه بستدعي كونستراكتور واحد فقط
            
            //اي اوبجكت انا بنشئه بستدعي كونستراكتر
            //حتى لو ما أنشئنها
            //اسمه ديفولت كونستراكتر بعطي قيم ابتدائية للمتغيرات
            
            //حتى لو ما أنشئنا كونستراكتور بعطي انيشال
            //الا في حالة يكون عنا اكتر من كونستراكتور بعطي ايرور
            //بناخد الديفولت من خلال انه نعمل كونستراكتر فاضي
            
            
            /*
            ملاحظة مهمة
            ممكن استدعي كونستراكتور داخل كونستراكتور
            مثلا كتبت كونستراكتور في براميتر معينة
            وحبيت اعمل كونستراكتور ثاني بزيادة براميتر واحد
            برجعش تاني اكتب كل قيمة في البراميتر اسندها في متغير
            لا
            بكتب ذيس وبكتب المتغيرات في براميتر الكونستراكتور اللي بدي استدعيه
            والبراميتر الاضافة بكتب ذيس لاسم المتغير وبعطيه هاي القيمة
            
            */
            
             
             //الفرق بين الكونستراكتور والسيت
             /*
               الكونستراكتورهو طريقة لإنشاء كائن جديد بنموذج أولي محدد...
             
             وظيفة "set"
             هي نوع خاص من الأساليب المستخدمة لتعيين قيمة خاصية كائن
             class Person {
            constructor(name) {
            this._name = name;
            }

            get name() {
            return this._name;
            }

            set name(newName) {
            this._name = newName;
            }
            }

            let person1 = new Person("John");
            console.log(person1.name); // Output: John

            person1.name = "Jane";
            console.log(person1.name); // Output: Jane

             */
             
             //النوع الرابع من الكونستراكتور
             //Copy Constructor....
             
             //لو انا انشأت اوبجكت  واستخدمت كونستراكتور ما
             //وعملت اوبجكت تاني وبدي انسخ فيه معلومات الوبجكت الاول//بروح بكتوب اسم الاوبجكت الاول داخل الثاني
             //ولكن بشرط اكون معرفة كونستراكتور فيه اوبجكت
             //وبكتب داخل الكونستراكتور هذا بيانات الكونستراكتور الاول بالطريقة هاي
             /*
              public Product(Product obj){
                  this.name=obj.name;//يعني الاسم اللي في هذا الاوبجكت انسبلي اياه للاسم
                    ......etc
             //ممكن بدل ما اضل اكتب البيانات هيك تكون
             this(obj.name, obj.descriotion,obj.price);
             }
             */
             
             //لو مثلا ارسلنا معلومات للاوبجكت من خلال كونستراكتور
             //كيف لو بدي اعدل على معلومة انا دخلتها من خلال دالة الست للبيانات
             
               //ملاحظة
             //اي اوبجكت بستدعي نوع واحد فقط من الكونستراكتر
             //الكونستراكتور الفاضي عشان نحط قيم بدائية
             //الكونستراكتور اللي بستقبل اوبجكت من الكلاس عشان لو بدي انسخ معلومات اوبجكت كمان مرة 
             
             
             //مصطلع عكس الكونستراكتور واللي بنستخدمه في حال الانتهاء من انشاء اوبجكت
             // Finalizers & Destructor
             //هاي الدالة انا بستدعيها لحتى تعملي تفريغ للسبيس لاي اوبجكت مش اكتف في المومري  وانا بشتغل على التطبيق
             //دالة بستدعيها كاربج كولكتر
             //لانه كل اوبجكت انا بستخدمه بستهلك سبيس في المومري
             //اسم مكان اللي بتخزن فيه ال//heap
             //الهيب الذاكرة المخصصة النا لحتى نستخدمها
             
             //وانا فاتح البرنامج تمام ولكن عند اغلاقه يتم تفريغ المومري من الاوبجكت اللي مش اكتيف
             //تطبيقات زمان كانوا بعانوا من هاي المشكلة
             //البرنامج كان يحجز مساحة وهاي المساحة ما تتفرغ
             
             
             
             //35
             //Static keyword
             
             //static
             /*
                 variable == لما بدنا متغير مشترك بين جميع الاوبجكت مثلا كلهم داخل كلية،لحتى ما نستهلك مومري
                 method ==لما نعمل خدمة مستقلة بذاتها ممكن استخدمها لجميع الاوبجكت مش خاصة باوبجكت معين
                        ==ما بقدر استخدم بداخلها الا متغير ستاتيك لو مش ستاتيك بنشئ بداخلها اوبجكت من الكلاس ومن خلال بستدعي النن ستاتيك
             
                 class == هذا الكلاس بكون داخل كلاس تاني لحتى يرتب الكود ولما يكون عنا دوال كتيرة
                       ==بنم استدعاءه عن طريق اني //اسم الكلاس.ستاتيك كلاس // اوبجكت//=اسم الكلاس.ستاتيك كلاس 
                 block ==لحتى نعطي لنسشال فاليو لستاتيك فاريبل ممكن تكون عبارة عن معادلات ضخمة عشان هيك الخ
                       ==بتم تنفيذها اوتوماتيكي عند انشاء الاوبجكت بدون استدعاء
                       ==بتشتغل اسرع من الكونستراكتور
             
              //فكرة الستاتيك بتلمسها باي تطبيق بتشوفه  
                  مثلا بتطبيق معين يوجد اختيار اللغة المناسبة
                   ويوجد اختيار الدارك مود او الاوايت
                   هدول مش حكر ع مستخدم معين فبنعمله ستاتيك فاريبل ..الخ
             
             */
             
             //مثال عندي كلاس للطالب
             //رقمه واسمه والكلية
             
             //الرقم واللاسم للطلاب مختلفية
             //لكن الكلية لو كانو بكلية وحدة معقول اجز الف فاريبل لاسم الكلية المشترك
             
             //من هنا يأتي فائدة الستاتيك
             //انه رح تخلي الفاريبل مشترك لجميع الاوبجكت
             
             //بهيك ما رح تنحجز مساحة للكلية
             //رح تنحجز مرة واحدة فقط
             //فقط للاسم والرقم
             
             //الستاتيك للفاريبل
             //بقدر اوصله من خلال اسم الكلاس نفسه دوت هذا المتغير
             
             //ايضا الرقم الجامعي
             //بحتاج انه اللي يعطيه هو السيستم
             //مثلا دفعة الفين 
             //الطالب اللي بسجل الاول رقمه الجامعي الفين وواحد وهكذا
             
             //مش كل طالب انا اكتبله رقم الجامعي
             //فكيف بدي استفيد من ستاتكيك فاريبل فهاي الارقام
             
             /*
             الحل هو اني اخلي متغير رقم الطالب 
             عبارة عن ستتيك ليكون مشترك بين الاوبجكت
             
             مثلا في الكونستراكتور 
             في كل مرة بزيد لرقم الطالب واحد
             
             لكن قبل بنعمل رقم الطالب ستاتيك
             وبنعمل متغير ستاتيك يساوي واحد
             وفي الكونيتراكتور بنضيف المتغير لرقم الطالب وبنزود عليه واحد
 
             لو كان رقم الطالب مش ستاتيك بخلي لكل اوبجكت متغير رقم الطالب لحاله
             لازم اعمل ستاتيك حتى يزيد ع القيمة واحد في كل مرة وهيك بكون مشترك بين الطلاب
             */
             
             
             //بستدعي اي شئ ستاتيك باسم الكلاس اللي فيه
             //مش بحاجة لاوبجكت استدعي الستاتيك من خلال هذا الاوبجكت
             
             
             /*
            private int no;
            private String name;
            private static String college="IT";
             
             public Student(int no, String name) {//بدون الكلية لانه مش بحاجة نغير على //كل الطلاب اللي بنعرف اوبجكت منهم رح ينتمو لنفس الكلية
            this.no = no;
            this.name = name;
            }
            
            /*
            @Override
            public String toString() {
                return "Student{" + "no=" + no + ", name=" + name + '}';
            }

            public static String getCollege() {
                return college;
             }
             */
             
             /*
             System.out.print(obj2.toString()+" The college is:"+Student.getCollege());
             */
             
            //لكن لو بدنا رقم الطالب يزود عليه النظام بواحد لكل طالب وبدايته تكون مشتركة
             /*
            ublic class Student {
            private static int no;             //private int no;
            private static int count=1;
            private String name;
            private static String college="IT";


            public Student(String name) {
                Student.no=count;              //this.no=count;
                this.name = name;
                count++;
            }

            public static int getNo() {
            return 202030+no;  ************
            }

            public static String getCollege() {
                return college;
            }

            @Override
            public String toString() {
                return "Student :" + "name= " + name ;
            }

            public static void displayInfo(){
                System.out.println("\t the number is :"+getNo()+"\t the college :"+getCollege());
            }
   
     
             */ 
             //class main
             /*
             Student obj1=new Student("Noura Sharif Hassanein");
            System.out.print(obj1.toString());
            Student.displayInfo();
            Student obj2=new Student("rohial Osama abosafia");
                System.out.print(obj2.toString());
                Student.displayInfo();
            Student obj3=new Student("Gaidaa rami Hamada");
                System.out.print(obj3.toString());
                Student.displayInfo();
            Student obj4=new Student("Assmahan fares Eky");
               System.out.print(obj4.toString());
                Student.displayInfo();
             */
             //output
             /*
            Student :name= Noura Sharif Hassanein	 the number is :202031	 the college :IT
            Student :name= rohial Osama abosafia	 the number is :202032	 the college :IT
            Student :name= Gaidaa rami Hamada	         the number is :202033	 the college :IT
            Student :name= Assmahan fares Eky	         the number is :202034	 the college :IT
             */
             
             
             
             //Static Methodes
             
             //مثلا الميثود اللي بكلاس الماث 
             //بنقدر نستدعيها من دون اوبجكت لانها ميثود ستاتيك
             //فقط من خلال اسم الكلاس دوت هذا الميثود
             
             
             /*
               private int no;
            private String name;
            private String password;
            private static int count=1;
            private boolean loggedIn;
            private static String college="IT";
            private static int minPassword=6;

            public Students(String name, String password) {
                this.no=count;
                this.name = name;
                this.password = password;
                ++count;
            }
            //بدنا نفحص هل الرقم الجامعي لطالب الاول بساويه وهل الباسوورد بساويه اللي دخلناه فالاوبجكت
            public boolean logIn(int no,String password){
                if (this.no==no&&password.equals(this.password)) {
                    return true;
                }
                else return false;
            }
            //بدنا نعمل دالة مش حكر على اوبجكت معين
            //لا تسمح بانه يكون الباسوورد اقل من ستة احرف
            //بعمل متغير ستاتيك من ست خانا
            public boolean miniPassword(String password){
                if(password.length()>=Students.minPassword)
                    return  true;
                else
                    return false;
            }

        }
                     */

                     /*
                     Students s1=new Students("noura", "202");
                System.out.println(s1.logIn(1, "202"));//true
                     */
                     
                     
                     
                     
                     
                    
           //36          
          //Static keyword (Static Block - Static Class           

          //اولا ستاتيك ميثود//static methods
          //اول خصائصها اني ما بقدر اوصل للنن ستاتيك فاريبل داخلها
          //الا اعمل داخلها اوبجكت للكلاس ومنه استدعي هذا المتغي
          //اما متغيرات الستتيك بستدعيها مباشرة باسمها
          
          //كما انه ما بقدر استخدم هدول الكلمتين فالستاتيك ميثود
          //this && super(inheretance) 
          
          
          
          //بنحط لكلاس المين ستاتيك لحتى نخفف  من ستهلاك المومري
          //لانه لو مش موجودة رح يعمل اوبجكت لكلاس المين
          //عشان يتم تنفيذ الاوامر اللي جواه
          
          
          
          //Static Block.....
         /*بكتبه خارج المين زيه زي الميثود اصلا
           static{
              //اي امر بكتبه مثلا امر طباعة بطلعلي فالاوت بت
          }
          */
          //بتم استدعاءه اوتماتيكي ما حد بستدعيه
          //استخداماته
          //يستخدم لنعطي انيشال فاليو للستاتيك فاريبل
          
          
          //لو بدنا نعمل مقارنة للستاتيك بلوك وللكونستراكتر
          //مين رح يتنفذ بالاول
          //الستاتيك بولك رح يتنفذ اولا
          
          //ممكن انشئ ستاتيك بلوك قد ما بدي
          
          //النن ستاتيك فاريبل ما بقدر استدعيها داخل ستاتيك بلوك
          
           /* Student2020 s1=new Student2020("Ahmed Ali",20203087);//داخل الكونستراكتور جملة طبعاة هلو

            }
            static int y=20;
            static{     
                y=22;
                System.out.println(y);
            }*/
            //22
            //hello
             
            
            
            //Static Class
            //لحتى يكون عنا هادا الكلاس لازم يكون كلاس داخلي بكلاس اخر
            //a nested class//Inner class
            
            /*
            public class Student2020{ 
             public static class Innerclass{
            
                    }
            }
            */
            /*
              public class Student2020{ 
                    static int x=10;
                public static class Innerclass{
                    public void display(){//في الكلاس الداخلي يوجد دالة بس فعليا كيف بدي استدعيها في دالة المين بدي اكتب اوبجكت من اي كلاس وعندي كلاس داخل كلاس
                        x=20;             //بعرف اوبجكت من الانر كلاس اللي هو الكلاس ستاتيك الداخلي 
                                          //بكتب اسم الكلاس الخارج دوت الكلاس الداخلي بعدها بعرف اوبجكت //Student2020.Innerclass obj1=new Student2020.Innerclass();
                        System.out.println("Hello Noura");
                    }

                   }
                }
            */
            /*
              Student2020.Innerclass obj1=new Student2020.Innerclass();
              obj1.display();//Hello Noura
            */
            //فوائد الكلاس داخل الكلاس
            
            //ممكن نحتاج دائما نعرف كلاس داخل كلاس اخر
            //بسبب ممكن وجود مجموعة دوال متشابهة
            //لكن اذا كان كلاس داخل كلاس ومش ستاتيك بعمل اوبجكت من الكلاس الخارجي وبستدعي الداخلي منه 
            
            //وممكن تزيد مفهوم الانكابسيوليشن//Enacapsulation التغليف
            
            //وبتوضح الامور للمبرمجين
            //بصير الكود سهل للصيانة
            
            
            
            
            
            //37
            //Passing Objects to Methods (by Value vs by Reference
            //Passing Objects as Arguments
            
            //Passing Objects to Methods...
            //سواء كانت على شكل
            //Argument to methods || Returning objects
            
            //ملاحظة تكون العلاقة في حال كانت رسمة كلاس دياقرام عبارة عن
            //كلاس به ميثود تستقبل اوبجكت من الكلاس الاخر تكون العلاقة
            //dependancy
            
            //call by value
            /*
               لما يكون ميثود بتستقبل قيمة وبتعمل تغييرات عليها
            وبنطبعها في التغييرات اذا كانت جملة الطباعة موجودة في الميثود
            
            ولكن لما نرجع نطبع هاي القيمة بترجع لقيمتها الاصلية بدون تغييرات
            //اي نوع داتا//premitive data type
            //بتم تمريره كول باي فاليو
            لاني انا ببعت قيمة اسم المتغير مش اسم المتغير نفسه
            
            لو بدي اغير عليه نفسه
            ببعت الريفيرانس الخاص بالفاريبل//الريفيرانس اي العنوان الخاص بالقيمة
            
            ما بنفع في البريميتيف داتا تايب
            
            الحل هو انه نعمل//wrap غلاف-لف
            للبريميتيف داتا تايب داخل الاوبجكت
            يعني رح استفيد من الكول باي ريفيرنس
            
            يعني رح اخد هاي المتغيرات واحطها فكلاس
            ومنه انشئ الاوبجكت
            وبهاي الحالة عنا  انستانس اللي هو الاوبجكت
            
            هاي المتغيرات البرايفت داتا
            فالميثود اللي بدها تستقبلها بكتب اسم الكلاس اللي هي فيه وبكتب اسم متغير
            ومن خلال اسم المتغير هذا بجيب الفاريبل اللي بالكلاس
            عن طريق اني كتب اسم المتغير دوت اسم المتغير اللي فلاكلاس وبنزد عليه او الخ بنعمل عليه عمليات
            
            اما فالمين بنعمل اوبجكت ومن خلاله بنستدعي المتغير وبنعطيه قيمة
            والاوبجكت بنبعته للدالة اللي بتستقبل المتغير باسم الكلاس اللي هو الاوبجكت
            وبهيك كانه بعتنا العنوان نفسه //اي كول باي ريفيرنس
            
            ورح يتغير قيمة المتغير في كل الوقت
            هذا عن طريق الاوبجكت
            */
           
            
            //call by reference
            /*
            هاي لما الميثود بتمرر اري
            بتطبع الاري بالتغييرات ولو بدنا نطبعها تاني بنلاقيها بتنطبع بالتغييرات
            
            */
            
            //Example
            /*
            public class Student2020{
                int number;
            }
            */
            /*
            main{
            Student2020 obj1=new Student2020();
            obj1.number=20;
                fun(obj1);
                System.out.println("number ="+obj1.number);//number =21
    
            }
             public static void fun(Student2020 num){
                num.number++;
            } 
            */
            
            
            
            //Retarning object
            //شو الفايدة منه
                                                                    //operater oweridding//؟؟ هذا الموضوع مش مدعوم بالجافا
            
            
            //كنا قبل مثلا دالة بتستقبل متغيرين وبتعطيني حاصل جمعهم
            //بنروح بنعمل متغير ثالث وبنحط جمعهم فيه وبنعمل ريتيرن اله
            
            //بقدر اعمل هيك للاوبجكت
            //الدالة//add(obj1,obj2)
            //obj3=add(obj1,obj2);|| obj3=obj1.add(obj3)           //obj3=obj1+obj2   //this erorr in java
            
            
            //مثال
            //عرفنا متغير فاليو في الكلاس
            //وعملنا كونستراكتور منه بستقبل فاليو 
            //وبداخله بحط هاي الفاليو للفاليو اللي فالكلاس اللي عرفناها
            
            //الدالة اللي بتعمل جمع للاوبجكت
            //بنكتب اسم الكلاس ثم اسم الدالة ثم في البراميتر قبلهم اسم الكلاس
            //والاوبجكت الثالث اللي بدنا نحط جمع التنين الاوبجكت بحط قبله اسم الكلاس
            //Course obj3=obj1+obj2 ==== Error 
            
            //مثلا كل اوبجكت اله قيمة اذن بنعرف متغير فاليو
            //Course obj3.value=obj1.value + obj2.value; =====Erorr!!
            //لازم نعرف الاوبجكت التالت قبل
            //Course obj3=new Course();===بنحتاج نعمل كونستراكتر فارغ ايضا
            //obj3.value=obj1.value + obj2.value;//لانه كل اوبجكت اله فاليو خاصة فيه
            
            
            //example
            /*
                //بدب اعمل دالة بتجمع تنين اوبجكت
                //اولا انا بنشئ الاوبجكت من الكلاس 
                 int value;
                public Student2020(int value){
                    this.value=value;
                }
                public Student2020(){

                }
                //هلحين لما اعمل تنين اوبجكت من الكلاس وبدي اجمع قيمهم كيف
                public  Student2020 add(Student2020 obj1,Student2020 obj2){//الدالة من نوع بترجعلي قيمة من نوع الكلاس نفسه //انتباه
                    Student2020 obj3=new Student2020();
                    obj3.value=obj1.value+obj2.value;
                    return obj3;
                }
            */
            
            /*
            Student2020 s1=new Student2020(20);
            Student2020 s2=new Student2020(30);
            Student2020 s3=new Student2020();
            Student2020 s4=s3.add(s1, s2);
            
            System.out.println("the s1+s2= "+s4.value);//the s1+s2= 50....

            */
            //ممكن الحل بطريقة اخرى
            //بدل//Student2020 s4=s3.add(s1, s2)
            //نبعت للدالة اللي فالكلاس اوبجكت واحد//add (Class obj2)
            //obj3.value=this.vale+ obj2.value  //الذيس فاليو مساوية للاوبجكت اللي بستدعي الدالة
            //لو عرفنا اكثر من متغير مثلا
            //بنحطهم عادي بدون ذيس رح ينعرف انه هاي خاصة بالاوبجكت
            
            /*
            Student2020 s3=s1.add(s2);
            System.out.println("The add number = "+s3.value);
            */
            
            
            
            //coparing object
            //كيفية مقارنة بين اوبجكت والثاني
            
            /*
               Student2020 s1=new Student2020(44);
                Student2020 s2=new Student2020(99);

                s1=s2;//لو بدون هاي بعطي جملة الايلس لانه الاوبجكت مش نفس العناويين
                if(s1==s2)//او بنحط الاوبجكت الاول دوت الايكولز للاوبجكت الثاني
                     System.out.println("Equle");
                else
                     System.out.println("Not Equle");
                //output ==Equle
            */
            // s1=s2;
            //وبعد مساواة الاوبجكت لما اعدل على الاوبجكت الاول بصير نفس التعديل فالثاني
            
            /*
            Student2020 s1=new Student2020(44);
            Student2020 s2=new Student2020(99);

            s1=s2;
            s2.value=33;
             System.out.println(s1.value);//33
            */
            //الاوبجكت ببتأثر بالتغيير //التنين بصيروا وجهين لعملة واحدة
            //اي تغيير بواحد بنعكس ع التاني
            
            
            
            //لو بدي اقارن بالدالة 
            //بعملها زي الدالة اللي قبل وبعبعت اوبجكت واحد
            //بترجعلي قيمة بولييان ترو او فولس
            /*
              boolean isEqule(Student2020 obj2){
                 return value == obj2.value; //ازا متساووين ترو اذا لا فولس
              }
            */
            
            
            
            
            //39
            //Inheritance (Types of Inheritance / Access Modifiers and inheritance)
            //في الوراثة السهم في رسم كلاس دياقرام بكون موجه من الابناء الى الاباء
            //سهم عادي
            
            //ملاحظة الوراثة تسمى العلاقة بين الكلاسات
            //Generalization
            
            //لما يكون الاتربيوتس مشتركة لكل الاوبجكت اللي بنشأها من عدة كلاسات
            //فكرة الوراثة بتوفر علينا كتابة الصفات المشتركة بدل ما اكتبها بكل كلاس
            
            //بجمع هاي الصفات داخل كلاس حجينيرال
            //بجمع كل الصفات فيه واي كلاس بحتاج الصفات رح اورثه منه هاي الصفات
            
            //وهبك بنكون حققنا مفهوم//Reusability
            //اللي هو اعادة الاستخدام//والصفات بتكون مكتوبة مرة واحدة
            
            
            //what do subclass inherit java?
            //شو اللي رح يتم توريثه بالضبط
            
            //field== variable | method | nested class  from superclass
            //P.s
            //Constructors not members
            //ولكن يمكن استدعاءها في الكلاس الفرعي من الكلاس الرئيسي
            //ولكن في كونستراكتر ينادى اوتوماتيكيا
            //no argement constructer| default constructors for superclass
            
            //شو السبب اني ما بقدر استدعي الكونستراكتور
            //لانه احيانا بحتاج اعدل  على القيمة للمتغيرات
            //او اعدل على بادي الميثود داخل الكلاس الفرعي من خلال اوفررايدينج
            //لكن الكونستراكتر ما بقدر اعدل على البادي اله
            //ما عندي اكسس او ما بقدر اعمله اوفررايدينج لحتى اعدل عليه
            //بقدر اعمله فقط
            //call || invoked
            
            
            //الكلاس الاساسي اللي فيه المتغيرات والميثود الجينرال اللي رح تتورث اسمه
            //superclass
            //parent class
            //general class
            //base class
            
            //اما الكلاس اللي برث منه بسميه
            //Subclass
            //child class
            //drived class
            //Extended class
            
            
            //Types of Inheritance
            
            //Single inheritance ==كلاس واحد فقط برث كل المتغيرات والميثود من الكلاس الاساسي 
            //Hierarchial inheritance ==الكلاس الاساسي يورث  اكثر من كلاس
            //Multilevel inheritance ==يوجد كلاس يرث من كلاس الابن//اذن بكون فيه المتغيرات اللي من الابن واللي من الكلاس الاساسي والمتغيرات الخاصة فيه
             /*
               لكن هاي الحالة انه مثلا كلاس يكون وارث من اكثر  من كلاس
            مش مدعومة بالجافا   
            بحيث انه تخلي اللغة اكثر سهولة   
            
            ولكن ممكن نحتاج هاي الطريقة ببعض الاحيان شو الحل   
            الحل انه يمكن تحقيقه بمفهوم //interface //multiple interfaces===implement
            
            */
            //hybrid interface ==انه يكون كلاس وارث من كلاسين مثلا وهدول الكلاسين وارثين من الكلاس الاساسي
            //لكن غير مدعوم من الجافا
            
            
            
            //كيف منطبق مفهوم الوراثة
            /*
            public class subclass extends superclass{
              وهان ح يكون كل الصفات الموجودة بالكلاس الرئيسي
            بالاضافة الى الصفات الخاصة فيه نفسه  
            //methods &fields
            }
            //ورح يكون عنا سبشالايز اوبجكت
            //اللي هو وارث صفات الرئيسي وصفات الكلاس نفسه
            //subclass obj=new subclass();
            
            //وفي مفهوم الجينرالايزيشن
            //اللي هو الاوبجكت اللي بكون فيه الصفات بالكلاس الرئيسي
            
            //وبهيك بكون علاقة بين الكلاس الرئيسي والابن 
            //وهاي العلاقة بنسميه
            //Is-A relationship
            
            */
            
            
            
            //Access Modifiers and inheritance
            //العلاقة بينهم
            
            //عنا اكسس موديفاير لاي متغير تمثل ب
            //public & private...
            
            //المتغيرات في الكلاس الرئيسي اللي بتكون برايفت ما  بتم توريثها فكلاس الابن
            //كيف رح استفيد من قيمتها؟؟
            //بكون في الها دوال//set() && get() ==بقدر استفيد منهم
            
            //اما ال//public
            //رح يتم توريثم وبقدر استفيد منهم مباشرة
            
            //واللي بدون برايفت وبابليك
            //بقدر استخدمهم في كل الكلاسيز اللي داخل الباكيج فقط
            
            
            //لكن لو بدي استفيد من الاتربيوتس بكلاس الاب اضافة الى كلاس الابن
            //بستخدم الاكسس موديفاير
            //protcted//اشارته بكون هاشتاج// #
            //بقدر اوصللها مباشرة بمجرد اكتب اسم المتغير من الكلاس السوبر
            //وبقدر اوصل للمتغير اله داخل الباكيج كاملا 
            //او بكج اخر في حال الكلاس فيه ورث من كلاس في الباكج التاني
            //بالنهاية بروتيكت بتستخدم بين كلاس الاب والابن
            
            //وايضا بقدر اوصل الها داخل الكلاسز اللي بنفس الباكج
            
            //مثال
            //كلاس الموظف حطينا فيه اسم وايميل ورقم وقسم وعنوان وسنة الميلاد
            //وانشأنا كونستراكتر فارغ وكنستراكتور بستقبل كل المتغيرات
            //وستر وجيتر لكل المتغيرات
            
            //وعملنا كلاس تاني موظفين اي تي وورث من كلاس الموظف بكلمة اكستند
            //وعملنا داخله كونستراكتور فارغ 
            //وضفنا اله متغير وعملنا اله ستر وجتر
            
            //في المين عملنا اوبجكت من كلاس الابن
            //ومن الاوبجكت لاحظنا بقدر استدعي كل المتغيرات والدوال الخاصة بكلاس الاب
            //ويوجد ملاحظة انه بمجرد ما انشئ اوبجكت من كلاس الابن
            //باي ديفولت رح يطبع شو في الكونستراكتور الفارغ لكلاس الاب وبعدها يطبع الكونستراكتور الفارغ لاي امر فيه لكلاس الابن
            //كونستراكتور فارغ اي نو بارامتر كونستراكتور
            
            
            //نلاحظ انه نتحكم بالمتغيرات من خلال الستر والجيتر
            //هنا الاتربيوتس مش المتغيرات
            //المتغيرات بقدر استدعيها باسمها
            //اما الاتربيوتس هي حالة من المتغير //بقدر استدعيها من خلال  اوبجكت دوت بعدين الاتربيوت
            /*
            int myVar; // attribute

            public void myMethod() {
            int myVar = 1; // variable
            System.out.println(myVar); // prints 1
            System.out.println(this.myVar); // prints the value of the attribute
            */
            
            
            //في المثال
            //لو عملنا كلاس تالث يرث من كلاس الابن
            //ومن ثم عملنا اوبحكت اله داخل المين
            //هنا رح يطبع ثلاثة كونستراكتور النو براميتر للسوبر وللابن اللي يعتبر سوبر للثالث وللكلاس الثالث
            
            
            //في المثال
            //لو انا بدي احط قيم في الاتربيوت
            //احنا عملنا من خلال الاوبجكت اللي انشاناه من الابن انه نستعدي السيت والجيت ونحط قيمة لكل اشي
            //بس احنا بدنا نحط القيم مرة وحدة بشكل اسهل
            //من خلال انه ننشئ كونستراكتور داخل الابن بستقبل المتغيرات الموجودة بالسوبر
            
            //لما عملنا مثلا كونستراكتور بستقبل الاسم
            //بداخله ذيس الاسم وبنخزن فيه الاسم
            //هنا ظهر ايرور لانه حاطيين للمتغيرات برايفت
            //الحل انه نستخدم الاكسس موديفاير//protected
            
            //بدل الطريقة المملة هاي
            //بما انه عندي كلاس السوبر اله كونستراكتر بستقبل الاتربيوتس وبحطيهم في الاتربيوتس الاصليات
            //بستفيد من اعادة الاستخدام في كلاس الابن
            //عن طريق اني اعمل كونستراكتر بستقبل هاي الاتربيوت كلها
            //وبداخله كلمة سوبر دوت شو ما بدي ولكن انا بدي الكونستراكتر//super(argements name superclass);
            //فبعمل سوبر وكتب اسماء الاتربيوتس كلها//ازا م كتبتهم وسوبر فاضية كاني استدعيت الكونستراكتر نو ارجمنت//super();
            
            //وبضيف الاتربيوتس الموجود فالابن بدون السوبر وبخزنه في المتغير من خلا ذيس
            //وبحط في كلاس السوبر تو سترينج اللي بتطبع قيم الاتربيوتس بعد ما ندخلها من خلال الكائن
            //اضافة انه بنوصل للمتغير الابن من خلال الاوبجكت دوت الجيت للمتغير
            
            
            
            //عشان عملنا اوبجكت من خلال الابن واستخدمنا براميتر كونستراكتر
            //ما رح يستدعي الباي ديفولت النو كونستراكتر البراميتر لاي منهم
            //لو كتبنا //super();
            //رح يطبعلنا النو براميتر كونستراكتر
            
            
            //ملاحظة 
            //لما انشانا كونستراكتر الابن فيه الاتربيوتس السوبر
            //جملة السوبر داخل الكونستراكتر لازم تكون اول اشي لانه الاولية للسوبر دائما والا ايرور
            
            
            //ومن خلال السوبر بستدعي الاتربيوت والميثود
            //نفسها نفس الذيس ولكن بالاتربيوتس والميثود الموجودين بالسوبر
            
            
            //احد الملاحظات
            //لو في المين انشأنا اوبجكت من السوبر 
            //ما بقدر اوصل منه للاتربيوتس او الدوال الخاصة بكلاس الابن
            //لانه الابن اللي بورث من الاب كلاس السوبر كلاس جينيرال
            
            
            //ملاحظة عامة
            //انه كل كلاس في الجافا بصير عليه وراثة
            //مثلا كلاس السوبر صح انه ما في كلمة اكستندز تدل على انه وارث من كلاس
            //لكن ضمنيا وارث من كلاس الاوبجكت فالجافا
            //هذا كلاس الاوبجكت بكون السوبر لاي كلاس مش ورثان
            
            //ويورث بعض الميثود
            //الدليل لما ننشئ اوبجكت بنو براميتر كونستراكتر
            //ونكتب اسم الاوبجكت دوت رح تظهر كل الدوال اللي بوررثها كلاس الاوبجكت للسوبر اللي مش وارث من حد
                /*
                   superclass e3=new superclass();
                   System.out.println(e3);    //print information for toString() in super class for all attributes
                */
            //احد الدوال تو سترينج
            //لو ما كتبناها في السوبر وطبعناعا من خلال الاوبجكت اله بنفع
            //ورح يطبعلنا اسم الكلاس والهاشينج كود...
            //لو استخدمنا دالة الهاش كود مباشرة رح تحول هذا الهاش لرقم صحيح
            
            //دالة جيت كلاس//رح تظهرلي اسم الباكج كامل ومن ثم اسم الكلاس
            
            
            //ملاحظة مهمة
            //لما بدي ارث كلاس وهو موجود ببكج تاني
            //لازم استدعي الباكج لهذا الكلاس من خلال الايمبورت//import package.superclass;//if .*; هيك بعمل دعم او انه بورث كل الكلاسيز الموجودين بالباكج
            //لكن الستار مش محببة بنكتب بس الكلاس اللي بدنا نرث منه فقط
            
                /*
                  import youtube2oop.Employee;
                  public class Noura extends Employee{  
                          public Noura() {
                           this.name="noura";//اقدرنا نوصل لمتغيرات السوبر لانها بروتكت
                    }
                   }
               */ 
            
            //Is A relationship
            //Developer extends Employee
            //المطورين عبارة عن موظفين //المطورين IS a موظفين//تماموز
            
            
            //41
            //Polymorphism (Method Overloading and Method Overriding) ===تعدد الاشكال
            //موضوع مهم ويتكون من هدول الدالتين
            
            //poly == more
            //phism== forms
            
            //many forms
            
            // methods & operators & object
            //النوع الواحد من كلهم ممكن نشوفهم بأكثر من شكل واكثر من نوع
            //وكل واحد منهم ممكن ينفذ أكثر من وظيفة بنفس الوقت
           
            //يمكن تحقيق تعدد الاشكال باحد الدالتين
            //Method Overloading  ==اخذناها قبل
            //same method name but diffirent signatures//السسيجنيتشر سواء اسم الميثود او اختلاف الباراميتر بالعدد او النوع
            //يعني بتكون عنا دالة مشتركة بأكثر من شكل مثلا من دوال كلاس الماث نفس اسم الدالة مرة بتجمع رقمين ومرة تلاتة
            //مثلا في برنامج المطعم تلات دوال للاوردر وحدة لما يكون الطلب عادي ووحدة لما يكون بدليفري ووحدة لما يكون بخصم الكبون
            //كل وحدة بتحسب السعر بطريقة مختلفة   
            //single action in diffirent ways
                /*
                        يعرف بالcompile time (static polymorphism
                        أوearly binding
                */
            //Method Overriding
                 /*
                        run-time polymorphism
                        dynamic method dispatch
                        late binding
                */
            //rules for java method overriding:==دوال اوفررايد يعني رح اعدل على الدالة
            //1- there are Is-A relationship(Inhirtetance)==لازم يكون عندي وراثة
            //2- same name
            //3- same parameter ===in parent & child class (method same signatures)
            
            //مثلا في كلاس الاب بتكن دالة بتحسب السعر حسب المنتج
            //وكلاس الابناء كل واحد عبارة عن منتج معين
            //من خلال الاوفررايد رح يستخدموا دالة السعر فكلاس الاب ولكن رح يعدلوا عليها 
            //يعني مش رح يكون السعر مجرد فيها مثلا ممكن في المنتج كزا خصم عشرة بالمينة والتاني عشرين وهيك
            
            
            //42
            //مثال
            //كلاس اساسي ومجموعة كلاسات الابن
            //لما انشئ كونستراكتور من الابناء بطلعلي كونستراكتور الاب اضافة للبيانات في كلاس الابن نفسه
            
            //هلا كلاس الاب فيه دالة السالاري الست والجيت
            //وانا ورثتها في عدة كلاسات الابناء 
            //ولكن في كل كلاس بدي احسب السلاري بطريقة معينة هنا بستخدم مفهوم الاوفررايد بكتب الدالة نفسها في كل كلاس الابن
            //ومن ثم الريترن بجيب السلاري الكلمة او المتغير عن طريق السوبر دوت جيت سلاري اي الدالة اللي بترجع السلاري وبنعمل عليها العملية 
            //مثلا الراتب ضرب تنين مثلا الراتب زائد الزيادة وهكذا
            //او بجيب السلاري من خلال انه نعمل السلاري بروتكتدت
             
            /*
             @Override
            public float getSalary(){
            return super.getSalary()+bouns;
            }
            */
           
            //عن طريق كلاس الاب ممكن اعملupcasting من كلاس الابناء
            //ومن ثم استدعي الميثود المشتركة بداخلهم//الميثود او الاتربيوتس
            //الميثود الموجودة بكلاس الابناء فقط ما بقدر استدعيها من اوبجكت الاب
            //هذا الاوبجكت بنسميه بوليمورفييك 
            
            //الاب كاستينج من خللال اوبجكت كلاس الاب بوصل لكل كلاسات الابناء وبستخدم الكونستراكتور الهم والدوال
            //بس بشرط تكون الدوال اوفررايدنج اي مشتركة بين الاب وهذا كلاس الاب
            //يعني الاب كاستينج بوجود الاوفررايد عشان هيك ما استخدمناه بالوراثة
            /*
                Employee e1=new Employee("Ali","Rafah",2000);
                e1=new SaEmployee("Ali","Rafah",2000,350,600);
                e1.getSalary(); ===بما انه هاي الدالة موجودة بكلاس الاب امبلويي ومعموللها اوفررايدنج اذن مش رح يعطي ايرور
                                ==ورح يتعرف على هاي الدالة انها خاصة بكلاس SaEmployee
            */
            
            //اذا بعمل اوفررايد لدوال في كلاس الابناء
            //بصير اقدر اوصل لكل كلاسات الابناء من خلال اوبجكت من كلاس الاب
            //اسم اوبجكت كلاس الاب يساوي نيو اسم كلاس الابن اللي بدي اياه وبختار الكونستراكتور اله
            //ومن خلال الاوبجكت بوصل لدالة اوفررايد
            //ومن نفس الاوبجكت بقدر اوصل لكلاس تاني وتالت واللي بدي اياه
            //ببستفيد منها لما يكون عندي حالة الاوفررايد
            //بعدين لما استخدم الاوبجكت واحط فيه كلاس الابن 
            //وبعدها من نفس الاوبجكت استدعي دالة الجيت سلاري بتكون خاصة بكلاس الابن اللي حطيته بالاوبجكت
            
            //سؤال مقابلات...
            //هل بامكاننا انه نعمل اوفررايد للستاتيك ميثود؟؟
            //لا
            //لا مش ممكن ولو جربنا واستخدمنا الاوبجكت لهاي الدالة رح تظهر القيمة اللي فكلاس الاب فقط
            
           //لو نعمل دالة نفس الاسم  وستاتيك
           //واستخدمنا تو اوبجكت واحد من الاب وواحد من الابن
           //وكل واحد استدعى دالته رح يظهر النتيجة الخاصة بكل واحد
           //لانه اعتبر كل دالة مستقلة عن التانية
           //كل ميثود بستدعيها بتعمل هايد للاخرى
           //وما بسير اعمل عليها عملية الاوفررايد 
           //لو كتبنا فوق الدالة فكلاس الابن اوفررايد رح يعطي ايرور
           
           
           
           //43
           // Polymorphism
           //(Early binding "Static Polymorphism", Late binding "Dynamic Polymorphism")
       
           //Early binding or Static binding
           //Method overloading ==copmile-time polymorphism
           //بتحققوا في النوع الاول من البولي مور فيزم اللي هو اللودينج
           //لانه يمكن تحديد الايرلي والستاتيك اثناء الكومبايل تايم
           
           //مثال 
           //لو انا عملت دالة وجيت اعمل نفسها بعدد الباراميتر والنوع 
           //رح يعطيني ايرور اثناء الكومبايل تايم قبل ما نعمل رن
           //كيف عرف:لانه الميثود هاي بنحجزلها في مكان في الذاكرة مباشرة اثناء كتابتها
            
           
           //Dynamic Polymorphism //late binding
           //runtime-time bolymorphism
           //MethodOverriding
           //هذا النوع ما ببين اثناء الكومبايل تايم
           
            //مثال
            /*
            لما انا علمت دوال اوفررايدينق من كلاس اساسي لعدة كلاسات
            وفي دالة المين عملنا اوبجكت من الكلاس الاساسي نوعه من كلاس معين
            ومن خلال اسم الاوبجكت استدعينا الدالة اللي معموللها اوفررايدينق
            
            هلا قبل التشغيل الكومبايلر ما بعرف لمين هاي الدالة 
            برضو الجافا فيجيوال مشين ما بعرف لمين هاي الدالة الا لما يروح يحجز للاوبجكت في الذاكرة
            اثناء التشغيل بعرف لمين
            
            عشان هيك نوع الاوفررايدينج بنطلق عليها ليت لانه بنعرف الدالة لاي اوبجكت متاخر
            */
            //مثال عملي
            //ممكن في كلاس المين نعمل دالة ستاتيك الباراميتر من نوع الكلاس الاصلي معرف باوبجكت
            //طبعا لو عملنا من كلاس الابن ما بتزبط الامور هاي بصير معروف انه هاي الدالة لازم نحط فيها كلاس معين
            //من خلال الاوبجكت ستدعيت دالة معموللها اوفررايدينج
            //في هاي الحالة الكومبايلر ما بعرف لمين هاي الدالة
            
            //رحنا لدالة المين 
            //كتبنا الدالة وحطينا نوع الاوبجكت 
            //اثناء التشغيل عرف لاي كلاس ابن هاي الدالة
            //print(new SalaryEmployee);
            
            
            //Polymorphic(Generic)   Array Types ==اسهل شئ واسهل كود فالمين لحتى نطبع كل اشي بخص الموظفين ضمن الكلاسات الابناء
            //رح نتعلم كيف الاري تقبل اوبجكت او ريفيرنس من كلاس معين
            //قبل كنا نتعلم انه القيم اللي بنخزنها في الاري لازم تكون من نفس النوع
            //لكن بمفهوم البوليمور  بنقدر نبني اري بوليموفيك جيناريك انها بتقدر تستقبل اكثر من نوع بنفس الوقت
            
            //مثال
            //لازم نعرف الاري من كلاس الاب
            //اولا بنكتب نوع الداتا للاري اللي هو كلاس الاب الخ
            
            //الاري الها علاقة بالاوفررايد
            //في دالة المين بنكتب
            //Employee refArray[]=new Employee[3]
            /*
             //بدي اعمل جمل الطباعة من خلال الاري
            Employee arr[]={new SaEmployee("Ali","Gaza",2000,500),
                            new daEmployee("Othman","Jeneen",4000,80,150),
                            new HoEmployee("Rahma","Sodia",8000,400,600)};
            for (int i = 0; i < arr.length; i++) {
                System.out.println(arr[i].toString());
                System.out.println(arr[i].getSalary());
            System.out.println("\n");
            }
            */
            /*
            
            وممكن نعمل الفور لوب هاي من خلال الفور ايتش 
            اولا بعطيها نوع هذا الاري ثم بكتب اي اسم اوبجكت وبخزن فيه قيم الاري
            for(Empoloyee e:arr){
                e.print();//ممكن نكتب دالة احنا كتبناها وخلص بدون ما نكتب الاوبجكت //بنكتب الاوبجكت بداخلها
                          //وممكن بدون هاي الاوبجكت نعمل دالة قبل دالة المين بتاخد باراميتر الكلاس الاصلي امبلويي
                          //وبتعمل منه اوبجكت وبداخلها من خلال هذا الاوبجكت بتستدعي دالة البرينت
            }
            */
            
            
            
            //44
            //Types of Relationships (Association, Aggregation "has-a", Composition "part-of"
            //رح نمثلهم ب===UMl==Object Diagram...
            
            //العلاقات بين كلاس والاخر
            //وكيف انه كلاس يستفيد من اوبجكت الكلاس الثاني
            //اخذنا//inheritance relationship(Is-A).==سهم مغلق فارغ
            
            //واليوم رح ندرس ثلاث علاقات اخرى
            //Association "has-a" relationship //منظمة
            //Composition "part-of" relationship//تجميع
            //Aggregation "has-a" relationship //تكوين
            
            //واحنا بنتعامل مع مجموعة كلاسات
            //احيانا واحنا بكلاس بنحتاج اوبجكت او دالة او متغير معيا من كلاس اخر
            //اذن لكي نتواصل من كلاس مع كلاس اخر
            //في هاي الحالة بستخدم //ِAssociation( connector)
            //هذا التواصل يتم عن طريق الاوبجكت الخاصة فيهم
            //Association مكونة من نوعين//unary or binary relationship
            
            
            //بدنا نتعرف على الاسسيوشن كيف بتعمل من خلال
            //UML == unified modeling language
            //واحنا كمبرمجين بنحول هذا التصميم لكود
            
            //unary Association==سهم عادي
            //في التصميم رح يكون في كلاسين بينهم علاقة
            //يوجد بينهم سهم من كلاس اي لكلاس بي هذه العلاقة اسيسويشن
            //السهم مختلف عن سهم الوراثة اللي بكون السهم فيها مسكر من قدام
            //المقصود بالسهم الموجه من اي لبي
            //انه كلاس اي بعرف عن كلاس بي
            //ولكن كلاس بي ما بعرف اي شئ عن كلاس الاي
            //على السهم علاقة //has a
            //مثلا كلاس اي عبارة عن شخص كلاس بي عبارة عن العنوان وموجه السهم من اي ل بي وعليه هاز اي
            //معناه انه الشخص اله اسم
            //ما بنحط العلاقة//Is a//الخاصة بالوراثة //بصير معنى الجملة الشخص هو اسم وهذا خطأ
            
            //ففي الحالة هاي في كلاس البيرسون بقدر استفيد من معلومات كلاس الاسم
            
            //Binary Association==سهم عادي من الجهتين سهم //==او سهم بدون رؤوس
            //يوجد كلاسين ويوجد سهمين بينهم الاتنين باشروا على بعض
            //او سهم واحد اله راسين من الجانبين//او خط موصل بينهم الاتنين
            //فالحالة هاي كلاس اي بعرف عن كلاس بي وكلاس بي بعرف عن كلاس اي
            //الطالب والمدرس ==*-1 has a
            
            //على السهم علاقة//has a
            //بجانبها //Multiplicity//1..*//بتكون باخر السهم وقبلها علاقة هاز اي
            //Multiplicity:تعددية//بتمثل  قديش ممكن نعمل اوبجكت من كل واحد
            //0..1 optinal instance(0 or 1)
            //n exactly n instance
            //* zero or more instance
            //1..* one or more istance
            //n..m n to m instance
            //والعلاقة بتنقرا من اليسار لليمين
            
            
            //3 type of Unary Association
            
            //1-Association most general
            
            //2-3هدول العلاقتين يطلق عليهم مصطلح//whole-part relatioship//معناها علاقة الجزء بالكل
            //2-Aggregation "has-a" relationship==سهم معين فارغ//المنظمة<uses>الموظفين
                    //كلاس اي وكلاس ب بينهم سهم على طرفه معين على شكل سهم غير مضلل متجه لكلاس اي
                    //معناه انه كلاس بي جزء من كلاس اي
                    //يطلق على هاي العلاقة//Aggregation  weak relationship
                            /*
                            علاقة ضعيفة صح انه كلاس بي جزء من اي  لكن كلاس بي مستقل بحد ذاته
                            لانه مثلا كلاس الموظف بي مرتبط بكلاس الكلية اي
                            لو راح هذا الموظف مش رح تتأثر الكلية
                            فبنستخدم السهم اللي عليه علاقة هاس اي وجنبها<uses>
                            والسهم المعين لازم يكون على المكان او الكلاس الاكبر مثلا هنا رح يكون على الكلية//whole الكلاس الاكبر
                    
                            بمعنى انه الكلاسين مش مرتبطين بشكل كلي مع بعض يعني ازا ادمر كلاس الكلية مش رح يتذمر الموظف
                           لما نجكي عن اشي اساسي بالكلية لازم يكون هاي بتكون علاقة قوية ورح ندرسها 
                            */
           //3-Composition "part-of" relationship ==سهم معين ممتلئ //المنظمة<Owns>الاقسام
           //بكون السهم على المؤسسة الاكبر وباخره المعين مضلل
           //والكلاس الثاني بكون ما اله اي معنى بدون الكلاس الاكبر
           //مثلا كلاس اي المنظمة وكلاس البي القسم مأشر على كلاس الاي طيب اذا راح كلاس الاي اصبح كلاس البي ما اله اي معنى
           //whole الكلاس الاكبر
           //part of الكلاس الاصغر
           //ٍالعلاقة بينهم في هاي الحالة//Strong relationship
           //<owns> بنحطها ع السهم ومعناها يملك//كلاس اي يملك كلاس بسي
           
           //}end of scop 
           //مثلا في اخر كلاس الاساسي عند نهايته الاوبجكت الاكتيف بتنمسح فالمومري 
           //ورح ينمسح معها الكلاس الجزء من هذا الكلاس//اللي بمسح الكاربج كولكتر
           
           //اما في Aggregation رح يكون في استقلاليةindependentlyفالموضوع
           //اذا انمسح اوبجكت من كلاس ما بنمسح اوبجكت الكلاس التاني
           
           //وبالتالي واحنا بنكتب بالكود رح نسمع مصطلح"death relationship"
           
           //ملاحظة
           //المبرمجين والشركات في الغالب بفضلوا يستخدموا علاقة
           //Aggregation
           
            
           //في التلات انواع للباينري اسيسويشن في فرق جوهري بينهم في كتابة الكود
           
           //1-Association
           //بكون عندي كلاس الاي بداخله دالة ولكن تستقبل اوبجكت من كلاس  البي
            /*
            public class A{
            void method(B objectB){
           //ولكن اوبجكت كلاس البي مش داتا ميمبر في كلاس الاي
           }
           }
            */
          //2-Aggregation "has-a" relationship 
             /*
           public class A{
             private B objectB;//لازم يكون عنا تعريف للداتا ميمبر ولكن هنا مش محجوزلها مكان في الذاكرةداخل كلاس اي
             A(B objectB){//ولكن ممكن يكون عندي كونستراكتور من الكلاس اي وبستقبل اوبجكت معين
                          //وهذا الاوبجكت ممكن اسنده للداتا ميمبر للي عرفته من الكلاس بي
             this.objectB=objectB;
           }
           //في هاي الحالة في كلاس المين بنشئ اوبجكت من كلاس الاي
           //واكيد ممكن انادي منه الكونستراكتر اللي بنشئ منه كلاس البي
          //لكن كلاس البي ممكن يكون تم تعريفه بشكل مستقل عن كلاس الاي
           //ولكن مش من خلاله بستدعي كلاس البي بنعمله اوبجكت مستقل ولو حذفنا اوبكت الاي ما بتأثر اوبجكت البي
           }
           */
          //3-Composition "part-of" relationship
          //رح يكون عندي اوبجكت من كلاس البي متعرف فعليا في كلاس الاي
           /*
           public class A{
             private B objectB=new B;
          //هذا الاوبجكت كداتا ميمبر خاص بكلاس الاي
          //يعني اذا انتهى سكوب الاي رح ينتهي معه اوتوماتيكيا اوبجكت بي
             void method(){
           }
           }
           */
            
            
        //لازم احضر الدرس اللي بعده اللي هو تطبيق عملي 
        //45    
            
        //في الاوبجكت دياقرام
        //اذا لاقينا موجود اوبجكت داخل كلاس من كلاس التاني
        //بتكون العلاقة اما كومبزيشن او اقرقيشن
        //بنحدد العلاقة من خلال قياسنا لمدى ارتباط الكلاسين مع بعض
        //الكلاسين واحد موظف والتاني معلومات شخصية
        //1-السؤال الاول لحتى نحدد العلاقة
        //هل بقدر انشئ موظف من غير معلومات شخصة هذا خطا اذن هذا مؤشر بأن العلاقة قوية
        //2-
        //الجزء الثاني هل المعلومات  part of اي جزء مهم من الموظف طبعا//اذن part of
        //3-
        //هل كلاس المعلومات الشخصية اله معنى بدون كلاس الموظف//لا  
        //اذن العلاقة كوموسيشتين
            /*
        public class Employee {

    private int id;
    private float salary;
    
    private PersonalInfo personalInfo;//عرفنا انستانس//Rel composition
    private Department department;//Rel Aggregation

    //بستقبل اوبجكت من كلاس المعلومات
    //وبستقبل اوبجكت من كلاس الديبارتمنت
    
    //البيرسونال دورة حياتها ماشية مع الامبلويي
    //وبالتالي بدل ما نبعت اوبجكت للامبلويي//PersonalInfo personalInfo==هيك اقريجيشن زي الديبارت منت
    //بنحط كل المعلومات مباشرة
    //وبنحط الاوبجت للبيرسونال داخل الامبلويي
    //بصير حاجز اله مساحة داخل الامبلويي وازا ادمر كلاس الامبلويي بدمر كلاس البيرسونال
    
    public Employee(int id, float salary, String firstName, String middleName, String lastName, String blooGroup, String accountNumber, String nationality, int yearOfBirth, Department department) {
        this.id = id;
        this.salary = salary;
        this.personalInfo =new PersonalInfo( firstName,  middleName,  lastName, blooGroup,  accountNumber,  nationality,  yearOfBirth);
        //لازم نعمل  اوبجكت من كلاس البيرسونال هنا 
        //لحتى تكون العلاقة كومبزيشن موضحة
        //لانه لو عملنا الاوبجكت للبيرسونال في المين 
        //بتصير دورة حياتها لحالها ببطل مفهوم كومبزيشن
        
        this.department = department;
    }

    @Override
    public String toString() {
        return "Employee{" + "id=" + id + ", salary=" + salary + ", personalInfo=" + personalInfo + ", department=" + department + '}';
    }
    //هان فالاوبجكت اوتوماتيكي كاني كاتبة لكل اوبجكت //.toString();
    //رح يناديها مباشرة كلاس الاب
    
    //كل كلاس عامل اوفررايد لسترينج
    //فلما دعينا الاوبجكت هان رح يعطي القيم مباشرة 
    //والا رح يعطي العناويين فقط    
    /*
    بالنهاية في علاقة Assoseation
      بنمثلها داخل كلاس الاب داخل كونستراكتور بستقبل الاوبكت من الكلاس الاخر
    ومن خلال الوبجكت بستخدم الجيت والسيت للكلاس ..الخ
    //الاسوسيوشن ما فيه انستنس فقط ممكن نستفيد من خدمة معينة عن طريق كونستراكتور او ميثود
    ولكن ما بعمله انستنس داخل كلاس الاب
    دايما اول ما اشوف انستنس داخل كلاس الاب بتكون العلاقة اما اجرجيشن او كومبوزيشن...etc
    */

      //كلاسmain
      /*
      public class Main {
    public static void main(String[]args){
        Department dept=new Department(2020,"IT");
        Employee e1=new Employee(202030,2000.5f,"Noura ","sharif ","HAssanin ","sash","Bloo","haa",2002,dept);
        Employee e2=new Employee(201930,4000.5f,"Saed ","sharif ","Amer ","sash","Bloo","haa",1999,dept);
        System.out.println(e1.toString());//لو كتبنا//e1 لحال رح ينادي مباشرة //toString()ويطبع القيم عادي
        System.out.println(e2.toString());
    }
    }
  
      */
            
      
        //46
        //Final Keyword
        //(Final Variable, Final Blank Variable, Static Final Blank Variable)
        
        //لفرض قيود على الكود الخاص بنا سواء
        //variable -method-class-parameter
        //بمعنى انه بدنا شخص معين ما يكون قادر على التعديل على كلا منهم
        
        //Final variable ==constant variable ==const variable
        //final DataType VARIABLE= final value
        //معناه انه اي متغير من نوع فاينل رح تتخزن فيه قيمة لا يمكن تعديلها
        
        //Final is non-access modifier
        
        //Final variable ==المتعارف عليه انه احرفه كابيتال
         final int YOUR_ID=996780;
         //YOUR_ID=88; == erorr
         
         //تعريف الفاينل بطريقتين
         //1
         //ممكن نعطيه القيمة عن طريق القيمة الابتدائية اي بالسطر نفسه
         //2
         //او عن طريق ال assaiment statement 
         //انه نعرف المتغير ونعطيه القيمة بعدين
         //اذا فالمين بتكتب المتغير والقيمة لكن اذا بكلاس بنعرف القيمة بعدين من خلال بلوك او كونستراكتور
         //اذا عملنا كونستراكتور فاضي وما كنا معطيين قيمة للفاينل بعطي ايرور انه لازم نحط قيمة للفاينل
         //بالمثال 
         //عرفنا متغير فاينل وانشئنا كونستراكتور بياخد براميتر ومن ضمنه هذا الفاينل
         //وعادي نفس الية اي متغير 
         //بس بما انه فاينل لما نيجي للمين وننشئ اوبجكت ونعطي قيمة للمتغير فاينل 
         //بتكون نهائية وما بقدر اعدل عليها باي طريقة
         //مثلا زي id للطالب  بحطه مرة وخلص ما بقدر اعدل عليه وللطالب التاني بدخله مرة وخلص ..الخ
         
         //ملاحظة
         //اذا كتبنا الفاينال فاريبل في كلاس لا بد من اعطاءه قيمة والا ايرور
         //2
         //سواء عن طريق القيمة الابتدائية او  الاسايمنت ولكن ببلوك
         //{YOUR_ID=996780}==بعد ما نكون معرفينه داخل الكلاس
         //او داخل كونستراكتور من الكلاس هذا
         
         
         //عندما ننشئ كونستراكتور بياخد البراميتر في الكلاس
         //رح يكون ديفولت فيه الفاينل
         //ولازم اسند قيمة متغير الفاينل للفاينل بالكلاس والا ايرور لانه مش معقول الموظفين ياخدوا نفس الرقم
         //done...
         
         //وفي كلاس المين مثلا 
         //بقدر احط قيمة الفاينل بس ما بقدر ارجع اعدل عليها لانها فاينل
         //ولو كانت برايفت بقدر اني ما اعدل عليها !!
         //ولكن بقدر اعمل دالة السيت في الكلاس ومن ثم استخدمها في دالة المين
         
         //فبدي انبه انه حتى اذا كانت برايفت لازم تكون فاينل عشان اتأكد انه مستحيل تتعدل القيمة
         //private final int YOUR_ID ;
         //ولكن بدالة ال set لمتغير الفاينل اعترض واعطاني ايرور ليش
         //لانه ما بتم تعريف الفاينل الا بطريقتين
         //اما عن طريق البلوك او عن طريق الكونستراكتر
         
         //...
         //لو اعطينا قيمة للفاينل عن طريق بلوك 
         //رح تكون ضمنيا مع اي اوبجكت انا بشئه من الكلاس
         //مثلا عملت داخل الكلاس كونستراكتر بياخد براميتر حتى الفاينل فاريبل
         //ولكن في كلاس المين لما انشئ اوبجكت من الكلاس واعطيه براميتر وبراميتر الفاينل
         //مش رح يعترف فيه رح يعترف بالقيمة اللي حطيتها داخل البلوك في الكلاس
         //والدليل لو طبعنا الفاينل رح تطلع قيمة البلوك
         /*final int YOUR_ID ;
         {  YOUR_ID=20203087 ;
          */
         //s.o.p(obj.YOUR_ID); ==20203087
         
         //البلوك بتنفذ قبل الكونستراكتر
         //لو حطينا جمل طباعة في كلا منهم وانشئنا الاوبجكت
         //في الرن رح نلاقي لكل اوبجكت مطبوع جملة البلوك ومن ثم جملة الكونستراكتر
         
         //ملاحظة
         //ممكن اعرف فاينل فاريبل يكون مشترك لكل الاوبجكت من خلال static
         //زي مثلا علامة النجاح =50 هاي قيمة ثابتة وبنفس الوقت مشتركة لاي طالب انا بدي اضيفه
         //ما بحط هاي القيمة داخل بلوك مباشرة
         //لازم داخل ستاتيك بلوك
         /*
         final static DEGREE_OF_SUCCESS;
         static{
            DEGREE_OF_SUCCESS=50;
         }//طبعا ما بنقدر نحط هاي القيمة داخل الكونستراكتر لا بد من دالة ستاتيك
          //فقط في البلانك ستاتيك
         */
         
         
         
         
         //47
         //Final Parameters, Final Methods, Final Classes, Final References
         
         //Final Parameters
         
         //مثلا في الكلاس في براميتر في  معرف مسبقا انه فاينل
         //وقيمته مسنودة لذيس هذا المتغير 
         //ولكن قبل هذا السطر اعطيناه قيمة اذن رح تنحفظ هاي القيمة لكل اوبجكت احنا بننشئه
         //وهذا مش منطقي اذن بنحط المتغير الفاينل لما صار براميتر بنحطه كمان فاينل
         //وبهيك ازا بدي اسند قيمة اله داخل الكونستراكتر بعطيني ايرور
            /*
               public FinalWord(final int ID, String name, int yearOFBirth) {
              //ID=2020;==Error ==يعني ممنوع تنحط قيمه للاي دي غير اللي بنحطها من خلال الاوبجكت وبعدين مش ممكن تتعدل
              this.ID = ID;
              this.name = name;
              this.yearOFBirth = yearOFBirth;
              }
           */
         
         //Final Methods
         
         //شو الفائدة منها
         //مثلا دالة toString عملتلها اوفررايد داخل كلاس الاب
         //وكلاس الابن بورث كل الدوال وبقدر يوصل لهاي الدالة ويعدل على اي قيمة مرجعة
         //طيب لو انا عندي دالة فيها معلومات حساسة او من ناحية انه فيها اعدادات مهمة
         //وما بدي حد يعمل overrideلهاي الدالة 
         //بروح بعمل لهاي الدالة final public ....etc
         //ازا بدي اعمل اوفررايد لهاي الدالة داخل كلاس الابن رح يعطيني ايرور
         
         
         //Final Classes
         //هذا لكلاس لهدف الحماية ما بدي حد يقدر اي كلاس يورث منه
         // او يعدل على البيانات او الدوال الخاصة فيه
         //final public calss Student{
         //هيك ما بقدر اي كلاس يورث منه extends==erorr
         
         //ملاحظة
         //مش معناه انه الكلاس final اني ما اقدر اعدل على بياناته في الدالخل
         //مثلا لو انشءنا اوبجكت من هذا الكلاس
         //بقدر احطله بيانات من خلال براميتر كونستراكتر
         //بس الفرق انه ما في كلاس بورثه
         
         
         //Final References
         //هل ممكن اتعامل معFinal References معينة؟
         
         //هسا لما انشءنا object || reference من كلاس معين
         //واعطيناه قيمة معينة  واحد هاي القيمة براميتر فاينل
         //لو نفس اسم الاوبجكت اخدناه وحطيناه بسطر واعطيناه قيم مغايرة وبالاخص لبراميتر الفاينل
         //مش رح يظهرلي ايرور وهنا ثغرة للمبرمجين
         //الحل انه نخلي هذا الريفيرانس او الابجكت فاينل
         
         //بكون مأمن انه id للطالب هو واحد وما حدا بقدر يعدل عليه 
         //لما احط للاتربيوتس فاينل وللبراميتر في الكونستراكتور فاينل
         //بضل احط للاوبجكت فاينل اني ما بقدر ارجع اعدل على الاوبجكت وبالتالي 
         //بهاي الطريقة بكون مسكر كل الطرق الممكنة للتعديل
         //final class obj=new class(...
         
         
           /*
           (final) FinalWord s1=new FinalWord(20203087,"Noura",2002);
                      s1=new FinalWord(2021,"Noura",2002);//لاحظنا اني بقدر اعدل على الاوبجكت //لكن بوجود فاينل عليه رح يعطي ايرور
                      System.out.println(s1); 
         */
         
         //ملاحظة
         //Final References
         //بقدر يستدعي اي دالة موجودة في الكلاس
         //بس انه ما بقدر اعمله reAssinet من جديد
         //obj.get...ايا كان
         //في اللغات الاخرى لا بد من انه يستدعي دالة فاينل
         
         
         //لو عرفنا فاينل داخل ايا من
         //بلوك || ميثود ||كونستراكتر
         //يطلق عيه مسماLocal final variable
         //اي لا بد من اعطائه القيمة الابتدائية داخل هذا البلوك 
         //بما انه معرف بهذا البلوك فقط
             /*
                public vois sum(){
                    final int x;
                }
                //x=20;==Erorr
             */
             
         //ملاحظة اخيرة عن الموضوع
         //1
         //لو عرفنا الفاينل داخل بلوك معين 
         //ما بقدر اعطيه قيمة الا انيشالايزيشن على نفس السطر فقط
         //ما بنفع اني اعرفها خارج البلوك local variable
         //2
         //Final variable داخل البلوك== good perfermance في عملية الرن اسرع ب 2ونص مرة
         //3
         //stop value change
         //stop method overriding
         //stop Inheritance.....done
         
         
         
         //48
         //ArrayList ==هي احد انواع data structur2
         
         //تم بناءها لتحللنا المشاكل الموجودة بالاري العادية
         //وهي عبارة عن كلاس  public class ArrayList{
         //من مكتبة java.util.ArrayList;
         
         //عبارة عن Dynamic Array الاري ليست
          //عبارة عن no size limit الاري ليست
         //المشكلة الاولى بالاري العادية
         //مثلا بالاري العادية بنحدد الحجم الها
         //وهنا في مشكلة مثلا لو انا بدي اضيف عنصر ما بقدر اضيفه بحجة حجمها واني ما بقدر اغيره
         //بس اجت الاري لست وحلت هاي المشكله باني بقدر احذف او اضيف عنصر بسهولة
         //وبنفس الوقت بالاري العادية ممكن احجز الف مكان وما استخدم غير عشر اماكن وهن في مساحة من الذاكرة بتروح هدر
         
         //فبدنا نغير limet هاي وانه يكون حجم الاري يتغير بناء على عدد العناصر اللي بضيفها للاري
         //دايركت اثناء الرن تايم
         
         //المشكلة التانية
         //لما اجي اضيف او احذف عنصر من موقع معين بحتاج وقت لحتى ابني دوال اضافة وحذف
         //بينما فالاري لست هناك دوال جاهزة //add(),remove();
         
         // كلاس الاري ليست في بداخله اوبجكت من الاري
         //من خلال الاوبجكت بستخدم الدوال الخاصة بكلاس الاري ليست من اضافة وحذف وتعديل الخ
         //الاري من الاوبجكت بهذا الشكل:
         /*
         ArrayList list=new ArrayList();
         لكن بناخد بعين الاعتبار انه الاوبجكت ما بياخد الداتا تايب بريميتيف  اللي هي انتجر وفلوت..الخ
         لازم الداتا تايب ياخده من كلاس معين هنا مثلا من كلاس الاري ليست
         
         //لكن ممكن يكون بدنا اري ليست جميع عناصرها انتجر او دبل الخ
         //رح يكون بهذا الشكل
         ArrayList <data type> list=new ArrayList();==هذا الشكل الافضل
         //او بهاي الاشمال تكتب
         ArrayList <data type> list=new ArrayList<>();
         ArrayList <data type> list=new ArrayList<data type>();
         //لكن الداتا تايب مش بريميتف داتا تايب 
         //ما بتستقبل داتا تايب بتستقبل اوبجكت تايب
         //رح نستخدم wapper class اللي رح يتعمل مع الاوبجكت 
         //اللي هو عبارة عن
         //Integer
         //Float
         //Double
         //Boolean
         //Character
         //وبما انهم اول حرف كابيتال اذن بنعرف انهم عبارة عن كلاس
         //String ==ولو حطيناها رح يقبلها لانه بالاصل هي عبارة عن كلاس
         */
         //ممكن يكون الداتا تايب كلاس احنا انشئناه==Student مثلا
         //كنوع اللاري ليست 
         //ArrayList <nameClass> list=new ArrayList();    
            
          
         //ArrayList==generic class
         //يعني بقبل اوبجكت او ريفيرانس ديتا تايب
         //سواء كلاس موجود باللغو او كلاس انا انشأته
         
         //كلاسات genaric class
         //ممكن ينحطلهم جنب اسم الكلاس
         //<T> ==type ==>لما نتعامل مع قائمة في اوبجكت تكون كل عنصر من نوع داتا تايب مختلف
         //<E> ==element ==>
         
            
         
         //ArrayList <Integer> list=new ArrayList();
         //عند هذا التعريف رح يروح يحجز داينمك اري
         //وهاي الداينمك رح يكون محجوزلها كابسيتي او مساحة معينة في الذاكرة
         //المساحة الابتدائية 10 مواقع== capacity=10
         //لما بدنا نضيف عنصر زيادة عن العشرة
         //تلقائيا بتزيد مساحتها لخمس مواقع وبضيف العنصر الجديد
         //والقائمة القديمة بتم حذفها عن طريق garbage collector
         
         //لما جينا نضيف عنصر واحد 10>>>1
         //كيف زادت مساحتها لخمس مواقع  
         //عن طريق انه نعمل للمساحة==right shift النقلة الصحيحة
         //هسا بشكل مختصر انه بنحول العشرة لباينري
         //رح نضيف رقم واحد يعني بنشيل البيت بمقدار واحد  كانت 1010
         //بعدين من الباينري بنشيل الصفر الاول وبطلع عنا 101
         //مجموعهم خمسة//بعد ما خولنا الباينري لديسيمال
         //ازن capacity = old capacity + new capacity
         //             =10           +5 =15
         //او حفظ بنجيب نص المواقع هنا عشرة وبنجمهم الها بطلع الرقم 15 هنا...
         //والمساحة دايما بتكون انتجر
         
         
         //بس بنلاحظ انه في ضل اربع اماكن فاضيين بالذاكرة
         //ولكن الاري ليست عندها حل لهاي المشكلة
         //انه بنستخدم ميثود اسمها ==trimTOSiza()==>رح تزيل المساحة المش مستخدمة
         //فبضل حجم الاري بالعناصر اللي انا ضفتها
         //size=11
         
         //من النت بنشوف الدوال الخاصة بالاري ليست
         //بنلاحظ انه اله 3 كونستراكتور
         //1- نو براميتر>>>>المساحة الاديفولت 10
         //2- البراميتر انتجر بدخل المساحة اللي بدك اياها==بنزيد البيرفورمانس لما نتوقع حجم الاري اللي بدنا اياها
         //3-الاري ليست بتستقبل كولكشن اي مجموعة عبارة عن :Interface ||other array list
         //والدوال كثيرة اضافة حذف تعديل ...الخ==لاندكس معين
         
         //الهرمية اللي ماشية فيها الاري ليست
         //ArrayList extends AbstractList implements List extends collection(interfase) extends Iterable(interfase)
         //الهرمية مهمة 
         //لانه ممكن نستخدم دوال عن طريق الكولكشن
         //وممكن نجز اوبجكت من list من خلال الاري ليست
         //List l=new ArrayList();
         //طبعا بالاعلى
         //import java.util.List;
         //الفرق بين اوبجكت اليست والاري ليست انه بنستخدم دوال اكثر فالاري ليس ت اما بشكل عام بادو نفس الغرض
         //فممكن نشوف تعريف الاري ليست بالطريقتين
         
         //ملاحظة
         //List l=new List(); ===Erorr
         //لانه الليست عبارة عن انترفيس والانترفيس مش ممكن انشئ منه انستانس او اوبجكت
         
         
         //هل الاري ليست مثالي لحتى استخدمه دايما
         //Access ==ممتاز مثلا عنصر الموقع الاول بجيبه بثانية والموقع الالف ايضا بثانية
         //Add,remove ==من هاي الناحية لما بدنا نضيف لموقع معين  فالنص مثلا بياخد وقت لحتى ينقل كل عنصر للمساحة اللي بعده وهكذا بالحذف
         //بصير عملية شيفتينج بس مش احسن اشي انه نستخدم الداتا ستراكشر الاري ليست
         //الحل الانسب استخدام الداتا ستراكشر LinkedList.....
         
         
         //49
         //تطبيق عملي للدوال
         
         //بهذا الشكل بنزيد البيرفورمانس لما نتوقع حجم الاري اللي بدنا اياها
         //ArrayList <Integer>l=new ArrayList(100);
         
         //add()==من خلالها بنكتب العنصر اللي ببدنا نضيفه
         //get(Index)== من خلالها بنجيب العنصر اللي بدنا اياه من رقم الموقع
         //size() ==بتحددلنا حجم الاري
         
         //الراندوم اكسيس في الاري العادية بتكون من خلال الاندكس مباشرة وبرجعلنا القيمة
         //اما فالاري ليست من خلال get(Index)
         /*
                ArrayList  <Integer>list=new ArrayList();
                list.add(10);
                list.add(20);
                list.add(30);
                 System.out.println(list);//[10, 20, 30]
                 int x=list.size();//انه نحط الحجم في متغير ونحط المتغير باللوب
                 for (int i = 0; i <x; i++) {//هيك بنكون استدعيناه مرة وحدة فالبورفورمانس افضل
                     System.out.println(list.get(i));
                 }//output
                 /*
                 10
                 20
                 30
         
                 //وبنفع نطبع العناصر عن طريق الفور ايتش
                for(int s:list){//بنحط اول اشي شو نوع العناصر اللي بدنا نطبعها
                System.out.println(s);
                 }نفس نتيجة الفور العادية
                 
                 //بس يوجد ملاحظة انه ليش حطينا عنصار الاري ليست في int مش Integer
                 //كونه الاري ليست بستقبل اوبجكت مش بريميتف داتا
                 //صح انه عناصر الاري ليست اوبجكت داتا ولكن بقدر اخزن عناصرها فبريميتف داتا تايب
                 //التنين صح ونفس النتيجة
                 
                 int y=list.get(0);//يتم التخزين فبريميتيف داتا تايب
         
                 */
         
         
         //بتنضاف العناصر بالترتيب وكل عنصر من جهة backe على اللي قبله بنضاف
         
         //كيف بدنا نضيف عنصر بموقع معين مثلا بعد ما كان عنا اري مثلا
         //من خلال
         //list.add(int idex,Integer Element);
         //لو بدي اياه يضيف على اخر موقع
         //add()==غير عن نستخدمها
         //رح نستخدم==list.add(list.size(),  Element);
         //هيك تلقائي بضيف بعد اخر عنصر ==لو قلنا list.size()+1 ==Exception
         
         //لو بدي اعمل اضافة لقائمة كاملة اي ميثود بستخدم
         //addAll(Collection);
         //مثلا بدي اضيف عناصر اري ليست على اري اخرى
         //l.addAll(list2); 
         
         //لو بدي اضيف قائمة من العناصر مباشرة مش اني اخدهم من قائمة
         //من خلال الميثود
         //asList==ولكن هاي الميثود موجودة بكلاس Arrays
         //list.addAll(Arrays.asList(200,300,400));==رح يضيف العناصر هاي على عناصر list
         
         
         //كيف بدي اضيف قائمة من العناصر عند اندكس معين
         ////list.addAll(Index , Arrays.asList(200,300,400));
         
         //وبالتالي النوع الثالث من كونستراكتر الاري==اسمهcopey constructre.
         //بقدر استخدمهه واحط فيه قائمة العناصر مباشرة
         //وظيفته يعطيني انشلايزيشن لعناصر الاري ليست
         //ArrayList <Integer>list=new ArrayList(collectin);
         //ArrayList <Integer>list=new ArrayList(Arrays.asList(10,20,30));
         //s.o.p(list); 
         /*
         10
         20
         30
         */
         //وبالتالي مهيئ انه يستقبل اي انستنت من اري ليست
         //ArrayList <Integer>list=new ArrayList(list2);
         
         //ايضا عنا ميثود بتنسخ عناصر من اري ليست لاخرى
         //clone();==بدل ما نستفيد من الكوبي كونستراكتر
         //هاي الميثود بتعمل ريترن لاوبجكت ومن ثم بنخزنها داخل اوبجكت اخر
         
         /*
         ArrayList <Integer>list=new ArrayList(Arrays.asList(10,20,30));
         ArrayList <Integer>list2;
         list2=list.clone();//Erorr==الاوبجكت ما بنفع نحولهم للاري ليست الحل انه نعمل اب كاستينج
         list2=(ArrayList)list.clone();
         System.out.println(list2);//[10, 20, 30]
         System.out.println(list);//[10, 20, 30]
         */
         
         //السؤال هو انه ليش ما استخدمنا
         //list2=list;==بعطوني نفس النتيجة
         //بس هذا ريفرنس كوبي اهم بعطوني عنوان واحد
         //يعني ازا عدلت على الليست وبعدها طبعت ليست تو بلاقيها معدلة
         
         //اما الميثود كالون بترجع
         //Shallow copey==نوع من انواع النسخ ولكن مختلف عن الريفرنس كوبي
         //ما بطبع التغييرات اللي بتصير بعدين على القائمة الاخرى
         
         //ملاحظة
         //ايضا الكوبي كونستراكتر ما بتمشي بنظام الريفيرانس كوبي
         
         
         
         //50 == تكملة الميثود
         
         //كيف بدنا نعدل على عنصر معين من خلال الاندكس
         //من خلال ميثود السيت
         //set(Index ,Element);
         
         //مسح عنصر معين يكون من خلال
         //remove(Index);
         //وفي عنا دالة بتستقبل الاوبجكت
         //remove(Object);
         //remove(10); ===Erorr:بس المفروض انها تحذف العنصر عشرة مباشرة
         //ولكن هيا بتستقبل اوبجكت هناك ثلاث طرق لحل المشكلة
         //1-تحويل الفاليو لاوبجكت
         //remove(new Integer(10));==هيك رح تحذف قيمة العشرة من الاري ليست==بعتنا اوبجكت من كلاس الانتجر
         //2-لكن يوجد طريقة افضل انه نعمل كاستينج للفاليو
         //remove((Integer)10);
         //3-او نستفيد من دالة فاليو اف في كلاس الانتجر:فبترجع الفاليو لاوبجكت تايب من خلال هاي الدالة
         //remove(Integer.valueOf(10));
         
         //ملاحظة اذا كانت الاري ليست قيمها من نوع String
         //اي قيمة ببعتها عبارة عن انستنس فاليو ما بحتاج اعمل كاستينق مباشرة بحط الفاليو وبتنحذف عادي
         //String==لانه بالاصل عبارة عن كلاس
         //remove("10");
         
         
         //لو بدي احذف قائمة او مجموعة عناصر من خلال
         //removeAll( collection);
         /*
           l3.removeAll(l3);
           System.out.println(l3);//[]  
         */
         
         //لو بدي احذف مجموعة من العناصر من قائمة معينة
         //list.removeAll(Arrays.asList("A");== رح تنحذف جميع احرف الاي من القائمة
         //وممكن احذف اكثر من عنصر من القائمة
         //list.removeAll(Arrays.asList("A"و"C");==رح ينحذف كل الاي والسي من القائمة
         
         //لو بدي احذف عناصر قائمة من خلال قائمة تانية
         //list.removeAll(list2);==العناصر الموجودة في القائمة التانية رح تنحذف العناصر هاي من القائمة الاولى
         
         //او من خلال كلاس كولكشن وبنعمله امبورت
         //removeAll(Collections.singleton("A"));
         
         
         //اذا بدنا نحذف قائمة من العناصر من اندكس معين لقبل هذا الانكس
         //Remove Range();
         //removeRange(Index ,Index);
         //removeRange(0,2);==رح يحذف الاندكس صفر لقبل الاندكس تنين
         //هاي الدالة معموللها بروتكتد الكسيز موديفاير الها
         //يعني بشوفها ازا كنا بنفس الباكيج اللي هو جافا دوت يتيل واحنا مش فيه 
         //اذن ما بقدر استخدمها الا ازا عملت للكلاس وراثة من كلاس اري ليست
         //extends 
         
         
         //لو بدي احذف عناصر بناء على شرط معين
         //removeIf(filter);==or codetion
         //removeIf(num->num%2==0); ==رح ينحذف العنصر اللي بنطبق عليه هذا الشرط ويمثل العنصر ب num هنا
         //لو انا مش محدد عناصر الاري ليست انها انتجر بعطيني ايرور الحل انه نعمل كاستينج للارقام ونحولها لانتجر
         //removeIf(num->(Integer)num%2==0);
         
         
         //ملاحظة اخيرة 
         //الاري ليست عبارة عن اري اوف اوبجكت 
         //الاوبجكت بلومورفيك اري كل اوبجكت منها مختلف عن لااخر
         /*
            Object arr[]=new Object[4];
            arr[0]=12;
            arr[1]="Noura";
            arr[2]='C';
            arr[3]=true;
            for(Object x:arr)//بما ان الاوبجكت اري عادية اذن ما بنطبعها مباشرة الا باللوب او فور ايتش
                System.out.println(x);
            /*
            12
            Noura
            C
            true
            */
        //وبالتالي بقدر اضيف اكثر من نوع داتا داخل الاري ليست مباشرة
        //اذا ما حددناها بداتا تايب معين اذن بتستقبل اكثر من داتا تايب
        /*
        ArrayList arr1=new ArrayList(Arrays.asList(12,"ali",false,'c'));
        System.out.println(arr1);//[12, ali, false, c]
        */
         
        
        
        //51
        
        //لفحص العنصر هل هو موجود او لا
        //contains();==بترجعلي ترو او فولس
        
        //لحتى نحصل على العناصر المشتركة بين قائمتين 
        //list.retainAll(list2);
        //هنا بمر على كل عنصر من اليست هل موجود في ليست تنين ازا اه بطبع حتى لو 
        //مثلا موجود بالليست اكثر من واحد وليست تنين واح بطبع اكثر من واحد على عددهم يعني
        //وممكن نبعت العناصر مباشرة يشوف شو المشترك
        //list.retainAll(Arrays.asList(1,2,3,1);
        //او ممكن بهاي الطريقة
        //list.retainAll(Collections.singleton(2));
        
        
        //لو بدي جزء من عناصر القائمة
        //من اندكس لاندكس معين
        //subList(Indext ,Index);==رح يطبع من عند لااندكس الاول لقبل الاندكس التاني
        
        //بدي افحص هل يوجد عنصار داخل الاري ليست
        //isEmpety();== بترجع ترو او فولس
        
        //لو بدي احذف جميع عناصر القائمة
        //clear();
        
        
        //الدالة اللي بتحددلي عدد العناصر اللي بدي اياهم
        //والبيرفورمانس بكون احسن لما اعرف اكم من عنصر بدي
        //لانه مبدئيا بكون عشر عناصر ولما بدي ازيد عددهم العملية بتاخد وقت اكثر نسبيا
        //ensureCapacity(عدد العناصر اللي بدي اياه);
        //ممكن بهاي الطريقة مباشرة 
        //ArrayList list=new ArrayList(200);
        //لكن احيانا بحتاج استخدم الدالة داخل شرط معين مثلا...الخ
        
        //وازا ضل اماكن فارغة من العناصر انا ما استخدمتها
        //بستخدم هاي الدالة
        //trimToSize();==بتمحي كل العناصر اللي مش مستخدمة
        
        
        //بنمشي على كل عنصر من الاري ليست وبنفذ عليه اكشن معين
        //forEeach(action);==ممكن الاكشن يكون عبارة عن ميثود معين والعناصر ارجمنت الها الخ
        //list.forEatch(e-> s.p.l(e +"-"));
        
        //------------------------------
        //طريقة ترتيب عناصر الاري ليست
        //من الصغير للكبير من خلال السور داخل كلاس الكوليكشنز
        //Collections.sort(list);
        //الترتيب تنازلي
        //Collections.sort(list,Collections.reverseOrder());
        
        //لطباعة عناصر الاري ليست بالعكس
        //Collections.reverse(list);
        
        //لطباعة اصغر عنصر واكبر عنصر
        //Collections.min(list);
        //Collections.mix(list);
        
        
        //--------------------
        //في مثالين اخر 15 دقيقة حلوين للتطبيق
        //في النهاية مثال جميل على الاري ليست لا بد من تطبيقه
        //وهو انه نبني ليست المستخدم يدخل ارقام سبيشال يعني ممنوع تتكرر لعند ما يتكرر الرقم بوقف البرنامج 
        //وبطبع جميع الاعداد
        //Distinict Elements
        /*
            ArrayList <Integer>list=new ArrayList();
            Scanner in=new Scanner(System.in);
            System.out.println("Enter Numbers: ");

            for (int i = 0; true; i++) {

               Integer num=in.nextInt();
                if(list.contains(num)){
                    System.out.println("Numbers of list: "+list );
                    /*
                     for(Integer e:list)
                        System.out.println(e);//بدون فور ايتش طبعنا اليست مباشرة وخلص
                    break;
                }
                else{
                    list.add(num);
                    System.out.println("Enter Number again;");
                    continue;
                }
           }
        */
        
        
        
        
        //52
        // Abstraction (Real-Life Examples, Introduction to Abstract Class, UML Abstract Class
        
        //اخذنا قبل
        //inheretance(Is-A)
        //Assoceation(Has-a /Part-of)
        //Polymorphisem(overloading/ overriding)
        //هاي المفاهيم بتركز على اعداة الاستخدام 
        //Code reuseablity
        
        //Data hiding( Private)
        //Encapsulation (setter/getter/private)
        //هاي المفاهيم بتركز على Security
        
        //Abstraction
        //المفهوم الجديد بتعامل مع الجزئين
        //رح يكون اله دور باعادة الاستخدام والامان
        
        //معنى هذا المفوم انه رح يصير عنا اخفاء في التنفيذ الداخلي لامر معين
        //hiding the internal implementation
        //او لدالة او ميزة معينة شو هي بتساوي يعني(methods,featurs)
        //وفقط رح نظهر ال functionality للمستخدم//او رح نظهرله الخدمة فقط
        
        //مثلا
        //لما احنا كمستخدمين نلاقي زر تسجيل دخول بعد ما حطينا الاسم والباسوورد
        //هو ظاهر اسم الزر فقط ولكن ما بنعرف شو بصير بعد ما سجلنا الدخول 
        //كيف طلبك انبعت للسيرفر وكيف انرد عليه وشو الخوارزميات والتنفيذ اللي صار وكيف رجع العنوان الك الخ
        //هاي الامور مخفية عن المستخدم ==هاي التفاصيل abstrated/hiden عنا
        
        //مثال اخر
        //لو انا صاحب تطبيق معين وبدي افعل خدمة الدفع عن الالكتروني
        //وانا ما اكون بانية اشي لهاي الخدمة
        //بروح لمزودين الخدمة للدفع ....
        //بطلب منهم يزودوني بالميثود المعينة اللي ممكن استخدمها
        //طبعا انا ما بكون عارف كيف تفاصيل الدفع تمت
        //الشركة صاحبت هاي الخدمات رح تعرض علي==API collections
        //وازا طبقت عليها request الخاصة فيك رح تستفيد من الخدمة اللي بنقدمها
        //بالنهاية رح استفيد من هاي السيرفس بدون مااعرف كيف انبنت
        
        
        //Type abstraction:
        //1-Data Abstraction
        //2-control abstraction
        
        //Ways to achive abstraction:
        //1-Abstract class (رح يحقق ابستراكشن جزئي 0-100%)==لانه ممكن يحتوي على ميثود ابستراكت وميثود كونكريت اي نن ابستراكت
        //2-Interface  (Fully abstraction 100%)
        
        
        //Abstract class
        //هذا الكلاس بسمحلنا ننشئ:blueprints for concrete classes
        //بمعنى بنشئ مخطط او هو نفسه كلاس الابستراكت==blueprints
        //اللي بقدر استخدمه ككلاس رئيسي لكلاسات تانية:concrete classes
        
        //مثال بدنا نعمل نظام بنك
        /*
       النظام فيه مجموعة من الدوال بتقوم بوظائف معينة 
        مثل دالة:الاعدادات -السحب-الايداع-تسجيل الدخول والخروج
        
        ولكن كل مستخدم او عميل اله نوع حساب مختلف عن الاخر
        في حساب من سن 18-في حساب للموظفين-في حساب لرجال الاعمال
        ولكن كلهم بشتركو بنفس عمليات معينة******
        */
        //بالنهاية هاي الدوال رح تكون مخطط رئيس لكل انواع الحسابات اللي رح نمثلها بكلاسيز اخرى
        //المخطط الرئيسي:عبارة عن Abstraction class==فيه دوال ابستراكت الاعدادات السحب الايداع الخ
        //والكلاسات الاخرى عبارة عن انواع الحسابات:Concreate classes
        
        //انا بعمل abstract class فيه الميثود كلها معموللها:abstract
        //بجيب مبرمجين للنظام
        //كل مبرمج بمسك هاي الميثود  وبعمللها:implenentation 
        //كل مبرمج ونوع الحساب اللي بنعطيه اياه بنفذ هاي الدوال
        
        
        //UML diagram
        //كلاس الابستراكشن بكون خط مائل
        //او خط عادي ولكن فوقه:<<Abstraction>>
        
        
        //ملاحظة
        //طالما عندي Abstraction class:كلاس الاب:كلاس اللي فيه الدوال المشتركة لكل الكلاسات
        //ازن في عندي عمليةInheretance
        //فلازم اورثه لكلاسات تانية : كلاسات الابناء: انواع الحسابات
        
        //في كلاس الابستراكشن 
        //الدوال :abstract==بدون تنفيذ
        //اما الدوال المنفذة مش ابستراكت
        
        /*
        public abstract class MyAbstractClass {
        // دالة أبستراكتية بدون تنفيذ
        //abstraction method==بتكون موجودة داخل كلاس الابستراكشن
        public abstract void abstractMethod();==طالما موجودة كلمة ابستراكت  ازن بجبر كل كلاس من لابناء يعمل تنفيذ لهاي 

        // دالة بتنفيذ
        //ممكن تكون بكلاس الابستراكت
        //كلاس الابستراكت بحتوي على دوال ابستراكت ونن ابستراكت
        public void concreteMethod() {
            System.out.println("This is a concrete method.");
            }
        }
        */
        

        //ملاحظة
        //1-
        //abstract class==بنعرفه بكلمة==abstract
        //abstract == non-access modifier.
        //2-
        //abstract class==بحتوي على
        //abstract(no body) and non-abstract methods.
        //3-
        //مش ممكن اعرف من كلاس الابستراكت انستانس او اوبجكت
        //4-
        //ممكن انه يحتوي على:final method & static method
        //5-
        //ممكن يحتوي على: Constructer 
        //شو فائدته بما انه ما بنقدر نعرف منه اوبجكت؟؟؟
        //الفائدة تكمن في السب كلاسيز
        //لما يكون في اتربيوتس خاصة فيهم وبدنا ننشئ كونستراكتر منهم اضافة لاتربيوتس كلاس الابستراكت
        //بروحك ببعتهم كارجمنت للكونستراكتر وداخله بحطهم في الاتربيوتس تاعت الكلاس الاساسس اللي هو الابستراكت 
        //من خلال كلمة :super(...);
        
        //6-
        //concrete class==بكون فيه جميع دوال الابستراكت معموللها تنفيذ 
        /*
        ونفس الشي لما نحكي عن conceret method
        بكون الدوال معموللها :
        (implimentation or body)
        */
        
        //ملاحظة
        //اول ما نشوف prototype لدالة معينة
        //void sum();
        //وكان تنفيذها داخل الكلاس نفسه او خارج لكلاس
        //ع طول بنحكي هذا abstraction الخاص فيها
        //لو بدي اعطيها لمبرمج تاني ينفذها
        
        
        
        
        //53
        //Abstract Class part 1 (Examples, Abstract rules
        //Abstract method
        
        
        //Abstract method==بلزم اي كلاس رح يورث من كلاس الابستراكشن انه يعمل تنفيذ لدوال الابستراكت
        
        //لحتى نميز الابستراكت بنضيف هاي الكلمة قبل الاكسيس موديفاير او بعده
        //public abstract
        //abstract public
        //للكلاس او الميثود
        
        
        //لما نيجي لكلاسيز الconcrete
        //ونعمل extends من كلاس الابستراكت==ُبعطي Erorr
        //امامنا خيارين
        //نعمل هذا الكلاس ابستراكت 
        //او نعمل overriding للدوال الابستراكت داخل هاي الكلاسيز :اي نعمل تنفيذ للدوال 
        
        
        //ملاحظة
        //مش ممكن نضيفabstract :لمتغيرات
        //مش ممكن نضيفabstract :لكونستراكتر
        //مش ممكن نضيفabstract :for static
        //مش ممكن نضيفabstract :for private==لانه البرايفت مش ممكن نشوفها بكلاس الابناء 
        
        //بس بنفع احط برايفت للسيت والجيت
        //بس هذا اشي مش منطقي لانه انا بدي استفيد منهم بكلاسات تانية تمااااااام
        
        //المثال العملي
        /*
        ننشئ ابستراكت كلاس كار في اتربيوتس وميثود ابستراكت
        واتنين كلاسيز ابناء نعمل وراثة لكلاس الابستراكتب بداخلهم تنفيذ لدوال الابستراكت
        اي اوفررايد الهم وبس
        */
        
        
        
        //54
        //Abstract Class part 2 (Polymorphism, Benefits of Abstract Class
        
        //Abstract Class
        //احد مميزاته انه بساعدنا كتيم انورزع التاسك بيناتنا
        
        
        //في المثال
        //لو انا بدي شخص معين يعمل تنفيذ لدالةابستراكت في ابستراكت كلاس داخل السب كلاس
        //لو كان عندي كزا دالة اب ستراكت وانا بدي اياه ينفذ دالة معينة رح يعطي==Erorr
        //الحل انه نعمل هذا السب كلاس ابستراكت كلاس بروح الايرور
        //بنعمل اوفررايد لدالة وبنحط الدوال الاخرى ابستراكت
        
        //ومثلا بدي مبرمج تاني يكمل هدول الدوال ويعمللهم تنفيذ في سب كلاس اخر
        //بروح بورث من السب كلاس التاني اللي نفذ دالة وضل دالتين
        //بعمل وراثة منه لانه المبرمج ممكن يحتاج الدالة اللي انعمللها امبليمينتيشن داخل السب كلاس التاني
        //والمبرمج بعمل امبليمنت لهدول الدالتين بكبسة زر
        //لو عمل لتنفيذ دالة وحدة منهم بس اكيد ايرور والحل نعمله ابستراكت كلاس
        
        //ممكن الدالة اللي تم تنفيذها بالسب كلاس الاول
        //استدعيها في السب كلاس التاني اللي ورث من الاول من خلال:
        //this.nameMethod; == Override
        //لما نعمل انتر بعد ما نكتب ذيس رح يستدعي الدالة ومعموللها اوفررايد
        //بطلعلنا خيارين للدالة
        //Override && implement (throw ..==هاي كلمة في الاكسيبشن)
        //بس احنا رح نختار الاوفررايد
        /*
        كلاس الابستراكت الاساسي :
        public abstract class Car {
                private int num;
                private float weight;
                private float height;

                abstract public void autopilot();
                abstract public void stremingServise();
                abstract public void sensorParking();
            }
          السب كلاس الاول:
        public abstract class AliMCI extends Car { ==Car:هو كلاس الابستراكت الاساسي
                @Override
                public void autopilot(){
                    System.out.println("HiAli autopilot()");
                }
                @Override
                public abstract void sensorParking();

                @Override
                public abstract void stremingServise(); 
          }==ولانه هذا كلاس الابستراكت ما بصير ننشئ منه اوبجكت والدالة اللي تنفذت فيه بشوفها من اوبجكت الكلاس اللي تحت
        السب كلاس التاني :
        public class AhmedMCI extends AliMCI{
                @Override
                public void autopilot() {
                    super.autopilot(); 
                }
                @Override
                public void sensorParking() {
                    System.out.println("Ahmed sensorParking()");
                }
                @Override
                public void stremingServise() {
                 System.out.println("Ahmed stremingServise()");
                }
            }
        */
        
        
        //ملاحظة
        //صح انه الابستراكت كلاس ما بنفع ننشئ منه اوبجكت
        //ولكن ممكن اطبق عليه مفهوم==Polymorphism
        
        //Car c1=new AliMCI();
        //c1.autopilot();==رح يروح للميثود الموجودة بالسب كلاس:AliMCI()
        
        //لو بدي انشئ ميثود بتستقبل اوبجكت
        /*
        public static void fun1(AliMCI obj){
            obj.autopilot();}
        
        public static void fun2(AhmedMCI obj){
            obj.autopilot();}
        */
        //ببعتلها الاوبجكت بهاي الطريقة ممكن
        //fun1(new AliMCI());
        //fun2(new AhmedMCI());
        
        //ملاحظة هامة
        //لو انا بدي اعمل دالة بتستقبل اوبجكت من كل سب كلاس 
        //ما بروح اعمل دالة لكل سب كلاس بتستقبل اوبجكت منه 
        //لحتى ينفذلي شغلة معين ع هاي الاوبجكت وبنلاحظ انها نفس الشغلة
        //بهاي الحالة انا بلاحظ اني ما ستفدت من مفهوم:Polymorphism
        //اللي هو اعادة الاستخدام ولكن بكتابة البيرنت كلاس بانه يستقبل اوبجكت
        //بهاي الحالة بقدر ابعت اوبجكت من اي سب كلاس وبكون حققت مفهوم الريوزبليتي
        /*
          public static void fun(Car obj){
               obj.autopilot();
        }
        */
        //هنا بنفس الدالة بروح استقبل اي اوبجكت من كل السب كلاسيز من خلال اوبجكت الكلاس الرئيسي
        //fun(new AliMCI());
        //fun(new AhmedMCI());
        //.....etc        
        //بالنهاية انه الاب من خلاله بقدر يأشر عباقي الابناء
        
        
        //ملاحظة
        //Car c1; ===not erorr ??!
        //لانه ممكن اكمل وعمل تنفيذ للسب كلاس
        //c1 =new AliMCI();
        
        //تكملة على الملاحظة
        //لو انا معرفة دالة تانية في السب الكلاس مش موجودة في البيرنت كلاس
        //وعملت على نفس المثال اللي فوق انه نفذنا اوبجكت سب كلاس داخل البيرنت كلاس
        //c1.الدالةالمش موجودة بالسوبر كلاس(); ==Erorr
        //لانه هاي الميثود لازم تكون مشتركة لو بدي استدعيها بهذا الشكل
        
        
        
        
        
        //55
        //Interface Part1 (Real-Life Example, UML, Convention
        
        //realization....
        
        //-----------------
        //**مبدئيا
        //الفرق بينها وبين Abstraction
        //Interface
        //انه هاي بنجمع بصفات مشتركة او مجموعة كلاسات ما الها دخل ببعض
        //في كلاس الانترفيس
        /*
        مثلا بين الانسان والسيارة هدول الكلاسين بنجمعهم بكلاس الانتر فيس بنبني دالة ابستراكشن اسمها الحركة مثلا
        void move();
        والانسان والسيارة عبارة عن كلاسين بعملو تنفيذ لهاي الدالة من خلال implements 
        */
        //Abstractino
        //هنا بنجمع في كلاس الابستراكت دوال مشتركة لمجموعة جزئية من هذا الكلاس
        /*
        مثال السيارة عبارة عن كلاس ابستراكشن فيه مجموعة من الدوال المشتركة 
        التي يتم توريثها لكلاسات انواع السيارتات ويتم تنفيذ الدوال فيها
        */
        
        //ملاحظة
        //هذا الفرق الي لحتى افهم
        //اما بالمقابلة بنحكي شو الفرق الفعلي
        //مثلا extend for abstract
        //implements for interface.......etc
        //----------------
        
        //الجزء الثاني من كيفية تحقيق الابستراكشن
        //ممكن نحقق مفهوم الابستراكشن عن طريق الانترفيس
        //interface عبارة عن
        //blueprent or template للكلاسيز اللي ممكن انطبقها
        
        //وهو عبارة عن التجريد النقي
        //pure abstraction in java
        //في الاصدار السابع للجافا كا ن يحقق الانترفيس الابستراكت بنسبة كاملة
        //JDK 1.7
        //اما بالاصدار التامن والتاسع تغير هذا الكلام 
        //بطلت نبة pure مية بالمية==بسبب التعديلات والاضافات واثرت على مفهوم الانترفيس
        
        //interface
        //1-
        //interface in oop java
        //مختلفة عن مفاهيم ui/ux
        //2-
        //list of method signatures (abstract methods).
        //كل الدوال بالانترفيس عبارة عن ابستراكت ميثود
        //3-
        //contract : عبارة عن عقد معين بيني وبين العملاءاو المبرمجين
        //4-
        //multiple inheritance: الانترفيس بطبق هذا المفهوم
        //انه ممكن كلاس واحد يورث اكثر من كلاس
        //ممكن الكلاسين اللي ورث منهم يكون الهم نفس البيانات الاتربيوت والميثود
        //عشان هيك الجافا او الوراثة ما بدعم هذا الشئ لكن الانترفيس ممكن يدعم هذا الشئ
        //لكن ضمن شروط معينة
        //5-
        //الاكلاس الواحد ممكن يعمل اكثر من implement لاكثر منinterface
        //class implements 1:M interface. (Does not extend)
        
         
        //الفرق العملي بين
        //interface &abstrract
        //1-
        /*
        الابستراك كلاس كان عبارة عن عملية وراثة هو سوبر كلاس
        وهناك سب كلاس الزامي يورث من الابستراكت كلاس ويعمل امبليمينتيشن للدوال في الابستراكت
        */
        /*
        من ناحية الانترفيس رح يكون كلاس انترفيس رح يتم انشاءه
        لحتى يكون عندي كلاسيز يعملوله امبليمنتس 
        ورح يكون بداخل كلاس الانتر فيس ابستراكت ميثود فقط
        لكن رح يكون عننا مصطلح امبليمنتس مش اكستندس
        */
         //extends ==ما بقدر استخدم هذا المصطلح بين
         //Interfase & Abstract == erorr 
         //او بين الانترفيس والكلاسات العادية ما بنفع الا امبليمنتس
         //extends
         //Interface & Interface ==True.
         
         //2-
         //UML
         //بين كلاس الابستراكت والسب كلاس
         //وبين الانترفيس ولاانترفيس
         //سهم متواصل رأسه مثلث فاضي== extends 
         //رح تكون في علاقة: Is-a ع السهم
         
         //بين الانترفيس والكلاسيز
         //سهم متقطع رأسه مثلث فاضي== implements
         //هذا نوع من انواع العلاقات وبنكتب فوق كلمة الامبليمنتس
         //<<realize>> : بمعنى تحقيق او انجاز
         //انت مجبر انك تحقق وتنجز جميع الميثود اللي بالانترفيس بالكلاسات العادية
         //ما رح تكون في علاقة : Is-a ع السهم
         
         //كلاس الابستراكت بخط مائل او خط عادي وفوقه:<<abstract>>مش لازم
         //اما كلاس الانترفيس خط عادي ولازم نحط فوقه:<<interface>>لازم
         
         //3-
         //ِabstract class
         //abstract method & non-abstract methods
         
         // interface class
         //just abstract methods
         //وعندي كلاس عادي ما رح يعمل وراثة لهدول الدوال فقط امبليمنتس
         
         //4-
         //في تعريف الابستراكت كلاس كنا نكتب
         //abstract class ClassName(){}
         
         //اما بتعريف الانترفيس ما رح نعرف كلاس معين رح نعرف انترفيس بحد ذاته
         //interface InterfaceName(){}
         
         
         //ملاحظةة
         //في تسمية الانترفيس بننهيه او بنبدأه ب
         //....able (لحتى يصير بمعنى متحرك مثلا)
         //Can....  (بنضيفها قبل وظيفة الانترفيس)
         
         //ممكن بالانترفيس يكون في متغيرات او دوال ابستراكشن
         //كيف الكومبايلر بشوفهم
         //int maxSpeed=250; ==(by defule) public static final int...
         //void maove(); ==(by defule) pubic abstract void..
         
         //في مجموعة كلاسات مسموحلها تعمل==implements for interface
         //اي كلاس انا بنشئه
         //الابستراكت كلاس
         //Nested class==كلاس داخلي
         //Java Enum ==رح نتعلمه مستقبلا
         //Java dynamic Proxy ==رح نتعلمه مستقبلا
         
         //الانترفيس==no have any constructers
         //------------------------
         
         
         //مثال عملي شو ممكن يفيدنا الانترفيس
         //ما تكلمنا على السيكيورتي في الابستراكشن كيف بحصل
         //سواء بنتكلم على الابستراكت كلاس او الانترفيس
         
         //مثال
         /*
         لو امازون عنده خيار الدفع عن طريق بطاقة البنك
         وامازون ما بعرف اشي عن هذا البنك
         وما الها وصول للميثود اللي بتنفذ شو بصير بالفلوس من دفع
         
         في هاي الحالة انه امازون بدها يكون في معاملة بنكية مع بنك
         بتطلب ربط مع هذا البنك
         والبنك بعطيها documentation معين بوضح لامازون كيف الامور بالتم
         ولكن ما رح يعرف التفاصيل او الايمبليمينتيشن كيف بتم وما بعرف كيف البنك بعمل تحديث لقاعدة البيانات الخ
         #بيعروفوا معلومات بسيطة على اساس يعرفوا عملية الربط كيف ممكن تتم
         
         فالبنك عنده كلاس فيه دالة بتاخد القيمة وبتعمل عليها اللوجيك
         وبتربط القيمة بقاعدة البيانات وبتعمل تحديث للداتا الخ
         هاي عبارة امبلمينت ما بتنعطى لامازون#وبهدف الامان البنك ما بعط التفاصيل لامازون
         ولكن امازون بحتاج هذا الكلاس ويعمل منه اوبجكت ويستفيد من هاي الدالة لحتى يرسل القيمة مثلا
         
         فالبنك لحتى يساعد جماعة امازون بعطيهم == interface
          بوضح السيجنيتشر الخاص بالميثود لحتى امازون يستفيدوا منها
          void withdraw( float amount);
          جماعة امازون عليهم يبعتوا القيمة والخصم بتم عن طريق البنك بعد هيك
         
         في بند مخفي عليا للفهم انه كيف رح يتم الخصم بالزبط 
          اولا في انترفيس بنشئه البنك وبعطيه لامازون
         فيه دالة معين بتقوم بالوظيفة اللي بدهم اياه جماعة امازون بس هي عبارة عن ابستراكت طبعا
         المطلوب من امازون انه تعمل امبلمنتس لهاي الدالة زي ما بدهم اي يعملو اوفررايد للميثود
         السؤال كيف رح يعملوا امبلمنتس وهما ما بعرفوا هاي الميثود كيف اشتغلت؟!
         البنك بزود امازون بدوكيميشن معينة تحتوي علىAPis معينة
         المفروض المبرمجين في امازون يستفيدوا منها
         
         ملاحظة
         APis ==عبارة عن وسيط بين امازون والبنك
         APis ==بنشئ براميترز معينة لاعمل  ريكويست للسيرفر الخاص بالبنك
         ......وفي تفاصيل رح اتعلمها بالمستقبل ان شاءالله في فلاتر الى الامام ي رب التوفيق
         APis ==بهدف السيكيورتي
         */
         
         
         
         
        //56
        //Interface Part2(Practical, Implement Multiple Interfaces, Extends Multiple Interfaces
        //Practical==عملي 
         
         //ملاحظة
         //لحتى ننشئ انترفيس من خلال الضغط على الباكج كليك يمين
         //Java Interface
         
         
         //مثال.........
         //بدنا نعمل نظام :SelfDrivable ==قابل للقيادة الذاتية
         //interface SelfDrivable {}
         //هذا النظام لازم يكون في جميع السيارات اللي بدنا نصنعها
         //يوجد بهذا الانترفيس مجموعة ميثود
         //1-destination(String):void ==سترينج عبارة عن المكان عن طريقه  بنعرف وين المسار اللي رح نتجه عليه
         //او عبارة عن :lat -long ==خطوط الطول طويلة== مسؤولين عن اي مكان في جوجل ماب
         //المكان عبارة عن رقمين جنب بعض بكونوا بالرابط
         //والدالة بتعمل تنفيذ بداخلها لحتى تخلي المركبة تروح ع المكان اللي احنا بنحدده
         //2-drive() :void
         //بتحددلنا طريقة تصرف المركبة --بنعلم المركبة عن طريق الذكاء انها تتخذ قرار بنفسها وين تروح
         //هنا يوجد ذكاء اصطناعي بالموضوع من خلال تعلم الشبكة العصبية والتعلم العميق
         //Deep Neural Network -- Deep learning
         //وفي هناك مجسات صوتية بتحدد للمركبة وين تروح وشو الاصوات اللي حولها...الخ
         
          //لازم ننشئ كلاس يعمل implements لهاي الميثود
          //car class
          
          //وممكن ننشئ انترفيس اخر مسؤول عن عملية تحديد الاتجاهات داخل اي مركبة احنا بنصنعها
          //interace Movable(){}
          //يوجد بداخلها دوال
          /*
              + moveUp() : void
              + moveDown() : void
              + moveLeft() : void
              + moveRight() : void
          */
         
          //بصير اي مركبة لازم نصنعها تعمل implemnts لهاي الميثود
          //class car implements SelfDrivable,Movable{}
         
          //ملاحظة
          //من كلاس انا بنشئه بقدر اعمل امبليمنتس من اكثر من واجهة بهاي الطريقة
          //class NameClass implements InterfaceName1,InterfaceName2,...{}
          //وهنا بكون تطبيق : multiple inheretanceعن طريق النترفيس 
          //اللي بسمح لكلاس معين يعمل امبليمينس لمالتيبل انترفيسيز
          
          //ملاحظة
          //ومن المميزات الاخرى للانترفيس انه بحد ذاته بقدر يعمل وراثة من اكثر من انترفيسيز
          //مثال النترفيس اللي انشئناه بالاول ممكن يورث من الانترفيس الثاني
          //interface Movable extends SelfDrivable{}
         
          //ملاحظة
          //في هاي الحالة لما قلت لكلاس الكار انه يعمل امبليمنتس للانترفيس موفابل
          //بنلاقي الموفابل عامل وراثة من الانترفيس سيلف درايف
          //فبصير لازم اكتب كل العملية
          //class Car implements Movable extends SelfDrivable {}
          
          //ملاحظة
          //ممكن يكون عنا انترفيس ثالث بورث من الاول والثاني
          //فلما نيجي نعمل كلاس بعمل تنفيذ للواجهة الثالثة بقول انها وارثة من الاولى والتانية
          // class .. imlplements ...extends...extends...{}
          
          //ملاحظة
          //خلينا نتخيل كل الكلام ب: UML
          
          
          //بالنهاية
          //التطبيق العملي عبارة عن واجهتين بدوالهم
          //الكلاس بعمل تنفيذ للواجهتين بنحط فاصلة بين الواجهتين
          //الكار مثلا بدنا نحدد قيمتين للاتجاهx,y
          //ونعمل كونستراكتر بستقبل القيمتين 
          //وانفذ دوال الانترفيسيز انحط بكل دالة معادلة معينة باستخدام القيمتين مثلا
          
          //ملاحظة ازا بدنا نثبت قيم معينة
          //بنحطها بالانترفيس لانه الاتربيوتس فيها عبارة عن static final 
          //String NAME-APP="Light";
          //كونه ستاتيك مش رح يكون خاص باوبجكت انا بنشئه من اي كلاس بعمل تنفيذ للانترفيس
          //رح يكون هذا المتغير خاص بالانترفيس نفسه:لحتى نوصله بكلاس المين بنكتب
          //Interface.NAME-APP="Light"
          
          
          
          //تطبيق مفهوم الريوزبلتي داخل الانترفيس وممكن نستفيد منه داخل الابستراكت الخ
          //ملاحظة
          //ممنوع انفذ انستنس من الانترفيس ولكن ممكن نطبق مفهوم البوليمورفزم
          //Interface i=new Car();==الريفرنس تايب عبارة عن انترفيس اما الحجز عن طريق الكلاس العادي اللي انشئناه
          //i. ==رح يجيب الميثود المشتركة بينهم فقط 
          
          //التكملة 
          //هنا تكمن الريوزبلتي مثلا لو عندي عدة كلاسات انا انشئتها ونفذت الدوال من هذه الانترفيس
          //بروح باخد نفس الريفرنس من الانترفيس وبعمل اله اعادة تهيئة
          /*
            Interface i=new car1();
            i.رح يجيبلي الدوال المشتركة بينهم وانا بختار شو بدي;
            //اعادة التهيئة
            i=new car2();
            i=new car3(); .....وهكذا هيك بكون حققت مفهوم الريوزابلتي
          */
          //ايضا الخيار التاني لتحقيق الريوزبلتي
          //مثلا لو بدنا نختار دالة معينة من كل الكلاسات اللي انشئناهم==هي هي الدالة
          //بعمل دالة بتستقب اوبجكت من الانترفيس وبتستدعي هاي الدالة
          /*
          public void(Interface obj){
             obj.الدالة اللي بدي الكلاسات يستخدموها;
          }
          */
         
          
          
          //57
          //Interface Part3 (Default - Private - Static Methods, Nested Interface,functional Interface)
          //الاضافات اللي صارت على الانترفيس في الاصدار الثامن والتاسع
          
          //في تعديل على مفهوم الانترفيس
          //في الاصدار السابع
          /*
          كنا مثلا لما بدنا نضيف ميزة جديدة عبارة عن ميثود لنظام مثلا
          وكنا منشئين انترفيس ومجموعة كلاسات عاملة امبليمنت لهاي الانترفيس
          لو حطينا الميثود الجديدة مباشرة في الانترفيس بعطي ايرور لجميع الكلاسات اللي عاملة امبليمنت لانه لازم
          تعمل تنفيذ ايضا للدالة الجديدة
          فكان الحل في الاصدار السابع عبارة عن::
          -انه نحط الميثود الجديدة بانترفيس ننشئه
          ومن ثم نعمل كلاسات اخرى مثلا الكلاس القديم كار ون بنخلي الكلاس الجديد كار احدعش بمعنى انه هذا الكلاس المعدل وبنكتب
          class car11 extends car1 implements Interface{
             @override
           public void newMethod(){
             s.o.p(.............
          }
          }
          وهكذا لكل الكلاسات.....ولكن هذه طريقة متعبة وتاخد وقت
           
          */
         //فظهر الاصدار الثامن غير من مفهوم الانترفيس لحتى يحل هيك مشاكل 
         //الحل هو انه نحط الميثود الجديدة ونحطلها بضي داخل الانترفيس اضافة الى كلمة ديفولت 
         /*
           defualt void NewMethod() {
                 s.o.p(".....");
            }==بنستخدم هاي الحالة في حال كان عنا اضافة ميثود جديدة والا كان بنينا كلاس عادي وخلص لو بدنا نستخدم ديفولت ميثود لحالها
         بنلاحظ انه بطل عنا تحقيق الابستراكشن باستخدام الانترفيس بنسبة مية بالمية اي تجريد نقي
         ببساطة بسبب انه بالانترفيس في دالة منفذة مش اب ستراكت
         
         السؤال هو لو بي اعمللها تنفيذ اي اوفررايد داخل اي كلاس كيف
         بعمللها اوفررايد بشكل عادي بس لازم الديفولت ميثود يكون الاكسيس موديفاير الها بابليك
         @override
         public void NewMethod(){
             sout...}
         */
         //ممكن استخدم الدالة الديفولت من خلال اوبجكت الكلاس اللي عامل امبليمنتس للانترفيس
         //بدون ما ارجع اعمل اوفررايد للدالة 
         
         
         //ملاحظات على لالاصدار التامن والتاسع
         //ملاحظةالحلاة الاولى
         //لو كان عندي بالانترفيس التنين نفس الدالة بنفس السيقنيتشر ووظيفتهم متشابهة مثلا
         //الجافا مفروض تمنع هذا لااشي زي ما هو ما بتدعم المالتي انهريتنس
         //انه ممكن كلاس يورث من اكثر من كلاس وكلاسين الاب فيهم نفس الدوال مثلا
         //اصلا بتعطي ايرور لو كلاس ورث من هدول الانترفيسيز==Erorr
         /*
         لحل هاي المشكلة ع الاقل نخلي السيقنيتشر مختلف مثلا نغير حرف باسم الدالة
         */
         
         //ملاحظةالحالةالتانية
         //عندي بالانترفيسيز التنين كل واحد دالة نفس السيقنيتشر بس انه وحدة معموللها تنفيذ بالديفولت والتانية لا
         //رح يعطي ايرور في الكلاس اللي عامل امبليمنتس لهدول الانترفيسيز==Erorr
         //لانه معروف لازم اعمل امبليمنت لدالة الابستراكت اللي مش منفذة اكيد
         //لكن منطقيا هذا الشي صحيح
         
         //ملاحظة الحالة التالتة
         //انه بنقدر انفذ دالة ستاتيك داخل الانترفيس
         /*
          static void methodName(){
                System.out.println("");   
            }
         *****
         شو بنستفيد منها!
         */
         
         //ملاحظة
         //لو عملنا كلاس في ميثود معينة وانترفيس في نفس الميثود بنفس السيقنيتشر هنا نفس الاسم
         //وعملنا كلاس يرث من هذا الكلاس وعمل امبلمينتس من هذه الانترفيس
         /*
         لو اجينا على المين وانشئنا اوبجكت من هذا الكلاس 
         ومن خلال الاوبجكت استدعينا الدالة اللي نفس الاسم رح تكون هاي الدالة تابعة 
         للكلاس لانه اقوى من الانترفيس والكومبايلر رح يعمل هايد لدالة الانترفيس 
         */
         
         //ملاحظة==الاصدار التاسع
         //في الاصدار التاسع سمح انه يكون عنا==private methods بنفذها داخل الانترفيس
         //اللابتوب عندي الاصدار التامن بعطي ايرور 
         //وممكن انه ميثود نن ابستراكت تستفيد من الميثود البرايفت عن طريق انه تستدعيها مثلا بنفس الانترفيس
         //مثلا الديفولت ميثود تستفيد من الدالة البرايفت تستدعيها داخل البادي تاعها
         //ملاحظة
         //اي ديفولت ميثود ضمنيا الاكسيس موديفاير الها==public
        
         //ملاحظة سابقة
         //انه لو استخدمنا متغيرات دالخل الانترفيس رح يكون الديفولت الها
         //public static final ...
         //يعني بنحط الفاينل اسم التطبيق والوان التطبيق عشان لما نعدل نروح عليهم وبس
         //LIGHT-MODE  DARK-
         //ولكن الملاحظة انه
         /*
         مش محبب نحط المتغيرات الفاينل او فاينل الاتربيوتس مع القيم اللي بدي اياها داخل الانترفيس
         بنحط هاي المتغيرات في كلاس عادي بننشئه وبنسميه  كونتاس مثلا وبنحط فيه فاينل بوبرتز او فاينل اتربيوتس
         */
         //السبب فهو انه الانتربيوتس عبارة عن كونكريت اي نموذج مخطط 
         //مش محبب يكون فيه ستيت او فيلد او اتربيوتس 
         //بنستخدمهم في الكلاسيز او ابستراكت كلاس
         
         
         
         //Nested Interface
         //بنلاقي اكثر من انترفيس داخل بعض اي بينهم علاقة لحتى اسهل واقسم الشغل علي
         //انترفيس داخل الانترفيس
         //بس الملاحظة انه كيف بدي مثلا انفذ الانترفيس الداخلي داخل كلاس معين==innerInterface?
         //بستدعيه من خلال الانترفيس الخارجي
         //class NameClass implements OuterInterfase.NesteddInterface {}
                  
         
         //Functional Interface
         //هذا المصطلح بطلق على الانترفيس اللي بتحتوي على دالة وحدة فقط
         /*
         @FunctionalInterface
         public interface TestInteface{
             void method();
         }
         */
         
         
         
         
         //58
         //Interface Part4(Marker or Tagging Interface, Generic Interface, Benefits of Interface)
         
         
         //Marker or Tagging Interface
         //عبارة عن انترفيس فارغ 
         //ما في بداخله اي فيلدز او سيقنيتشر لدالة معينة
         //مثال على هاي الانترفيسز المشهورة
         //Serializable,remote ,EvenListner Interface
         
         /*
         لما ننشئ اري ليست من الانترفيس ليست
         ونروح نشوف الامبليمنتيشن الخاص بالاري ليست بنلاقيها عاملة امبليمنتس لعدة انترفيسيز من ضمنها مثلا==ctrl +click ع الاري ليست
         السيرالازابل الانترفيس الغارغة
         */
         //ما هي مهمته
         //اضافة ادونات او صلاحيات معينة
         /*
         بمعنى مثلا اي كلاس عامل امبليمنتس لانترفيس معينة مثلا انترفيس هاي الفارغة
         رح نعطيه وظيفة
         */
         //مثال عملي
         /*
         في البداية انشئنا كلاس عملنا فيه امبليمنتس لكلاس فارغ
         ثم في المين انشئنا اوبجكت من الكلاس وباستخدام دالة انستنس اوف بدنا نفحص عامل امبليمنتس للانترفيس الفارغ او لا
         وينفذ امر معين
         if(obj instanceof Tagging Interface)
            s.o.p(".....");
            else
            s.o.p(".....");
         //دالة انستنس اخدناها في الاساسيات==instanceof
         //ُ لفحص ما إذا كان كائن معين ينتمي إلى نوع معين أو يمكن تحويله الى هذا النوع
         */
         //ايضا فكرتها رح تيجي لما نتعامل مع==Files
         
         
         //Generic Interface
         //الجينارك تعاملنا مع هذا المصطلح لما استخدمنا الاري ليست انه ممكن نتحكم بعناصرها يكونوا انتجر دبل
         //مثال عملي كيف انه الجينارك مطبق على الانترفيس
         /*
         علمنا انترفيس فيها دالة بترجع اوبجكت وما حددنا شو نوع الاوجكت
         public object method();
         ثم عملنا كلاس عمل امبليمنت لهاي الانترفيس اي اوفررايد لهاي الاوبجكت وانها بتعمل ريترن لاوبجكت من نوع هذا الكلاس
         
         في المين
         عملنا ريفرنس  من الانترفيس مهيئ فيه اوبجكت هذا الكلاس
         ثم انشئنا اوبجكت من هذا الكلاس وخزنا فيه الدالة اللي بترجع اوبجكت باستخدام الريفرنس
         بس اعطانا ايرور لانه انا صح حددت الريترن عبارة عن اوبجكت من اي كلاس  ولكن الدالة نفسها اي شو نوع الاوبجكت اللي بترجعه ما حددناه
         الحل هو انه نعمل كاستينج 
         //ImplimentsClass obj=(ImplimentsClass) reference.method();==True
         //ImplimentsClass obj= reference.method();==False
         */
         //generic مفهوم
         /*
         هي ميزة تسمح للمطورين بإنشاء كلاسات وواجهات وأساليب قابلة للتعميم،
         وبذلك تمكنهم من كتابة كود يمكن أن يتعامل بشكل عام مع مختلف أنواع البيانات.
         */
         
        
         //بدنا نطبق مفهوم الجيناريك على الانرتفيس بطريقة اسهل
         //جنب الانترفيس <T>
         //رح نستخدم:<T> templet==لانه رح نستخدم دالة ترجع اوبجكت واحد
         //مش رح نستخدم<E> Elements :عدة عناصر
         
         //ورح نروح ايضا للكلاس ونخليه امبليمنت بعمل امبليمنتس للانترفيس التيمبلت
         //والدالة اوفررايد بترجع ريترن فاليو تايب تيمبلت
         //وبنعمل كاستينج للريتين تيمبلت كونه برجع تيمبلت
         /*
         class NameClass <T> implements InterfaceName<T>{
             @Override
             public T method(){
                 return (T) obj.class();
         مثلا الكلاس عبارة عن كار 
         وهنا بدي ايرجعلي اوبجكت 
         لما استخدمنا مفهوم العامية
         سهل علينا بالمين ما خلانا نحتاج نعمل كاستينج للاوبجكت فقط حددنا النوع بالانترفيس بالمين
         Interface <Car> c1=new Car();==بس لحظة انشاء الانترفيس بنحدد انه العناصر اللي رح نتعامل معها من الاوبجكت من نوع كار
         بس بالانترفيس بنحدد النوع  وممكن يكون عنا كلاسات تانية زي انواع السيارات
         الها علاقة بكلاس الكار فبنحدد من نوعه وبنرجع بنعمل تهيئة لاي نوع كلاس انه البوليمورفيم من خلال اوبجكت من الانترفيس
         Car obj= c1.move(); وهنا بنبطل بحاجة نعمل كاستينج للاوبجكت اللي بنشئه
         Car obj=(Car) c1.move(); ==مش بحاجة نعمل هيك لما طبقنا مفهوم العامية
         */
         
         
         
         //Benefits of Interface متى ممكن نستخدم هذا المفهوم وليش
         //1-security:لحتى نحقق مفهوم السيكيورتي ببعض الحالات
         //2-Multiple Interfaces ==اجى الانترفيسس سمح بالمالتي علما بان الجافا منعت مفهوم المالتي انهريتنس
         //3-extends:سمح بالاكستند بين الانترفيسز
         //4-loose coupling:الانترفيس حقق هذا المفهوم انه يكون في عنا استقلالية بين الكلاسيز==independent classes
         //يعني الكلاسات مش معتمدين على بعض هذا احسن اشي في التصميم الجيد في الكلاس ديقرام مثلا
         
         
         
         //----------------------------------------------
         //59
         //Anonymous Inner Class (Extends Class, Implements Interface, Defined Arguments
         
         //المعنى المجرد هو مجهول الاسم رح يكون عنا كلاس داخلي ما رح يكون اله اسم معين
         //الفايدة منه
         //1-يكون عنا كود مختصر==code more concise
         //2-ممكن نشوف تعريف لكلاس وانشاء منه اوبجكت بنفس الوقت
         //3-المبرمجين بفضله يستخدموا اذا بدهم يستخدموا local class only once
         //4- nameless inner ...== anonymous inner class
         //5-رح نستخدمه لما نتعامل معListener interface في برمجةالرسومات==لما نتعامل مع الاندرويد مثلا 
         //مثاله Event listner ==انه المستخد في تطبيق الموبايل لو ظغط ع زر معين رح ينفذ حدث معين وعنا كثير انواع
         
         //وين ممكن نشوف هذا الكلاس
         //1-عاملextends a class (Abstract or concrete)
         //2-عاملimplements an interface
         //3-عبارة عنargument of method/constructor
         
         
         //مثال عملي
         //عندي كلاس فيه ميثود بتنفذ اشي رحنا ع المين انشئنا عدة اوبجكت ومن خلالهم استدعينا هاي الدالة
         //لكن انا عند اوبجكت معين بدي انفذ الدالة بشكل مختلف
         //الحل القديم
         //رحنا انشئنا كلاس جديد برث من هذا الكلاس وبنعمل اوفررايد لهاي المثود داخله
         //ثم في المين برح لهذا الوبجكت اللي بدي استخدمه بشكل مختلف وبهيئ فيه اوبجكت من الكلاس الجديد
         //وبستدعي من هذا الاوبجكت الدالة المعموللها اوفررايد
         
         //ولكن في حل اسهل بماانه رح نعدل ع دالة معينة وحدة
         //انه ناخد هاي البدي اللي انشئناها داخل الكلاس الجديد اللي معمول اوفررايد للدالة
         //ونحطها في المين مباشرة جنب الاوبجكت اللي انشئناه من الكلاس القديم
         /*
            Class obj=new Class(){
                 @Override
                 public void method(){.....
         };
         */
         //ملاحظة
         //هذا الكلاس اللي عبارة عن بادي بدون اسم انا حطيته يعرف ب==Anonymous Inner Class.
         //كلاس ما اله اسم وبنلاحظ انه كلاس داخلي
         //وهذا الكلاس بأدي غرض الكلاس اللي احنا انشئناه بعمل وراثة عشان الوفررايد للدالة الخ
         
         
         
         //ملاحظة ==getClass
         //في دالة بنستخدمها لحتى نحدد الانستنس تم تعريفه من اي كلاس
         //s.o.p(obj.getClass);==رح يطبع هذا الاوبجكت جاي من اي كلاس
         //بنلاحظ
         //الاوبجكت من الكلاس العادي بطلعلنا انه من الكلاس العادي
         //اما الانر كلاس
         //بطلعلنا الاوتر كلاس مع اشارة الدولار انه في انر كلاس وبعد علامة الدولار اسم لاانر كلاس==OuterClass$1
         //في حالتنا الانر كلاس ما اله اسم فالكومبايلر ببدا بعد الانر كلاس هذا اللي انشئناه الاول اذن بعطي رقم واحد
         
         
         //ملاحظة
         //اذا بدي استدعي الدالة اللي معموللها اوفررايد عن طريق المانيوس انر كلاس مرة واحدة فقط
         //بقدر استدعيها بدون انستانس بهاي الطريقة
         /*
         new Class(){
                 @Override
                 public void method(){...}
         }.method(); ==بهاي الطريقة
         */
         //بس مثلا انا في نظامي بحتاج الريفرنس عشان اقدر استفيد من القيمة لاحقا
         //مثلا اطبع الريفرنس دوت هذه الدالة هيك يعني
         //بالنهاية اذا بدي انفذها مرة واحدة بستخدم هاي الطريقة اما اذا اكثر من مرة لا بحتاج الريفرنس
         
         
         
         //الطريقة التاني اللي بنستخدم فيها الانانيمس انر كلاس انه يعمل تنفيذ لانترفيس معينة
         //Implements Interface
         
         //مثال عملي
         //انه عنا انترفيس فيها ابستراكت ميثود وحدة
         //بدل ما نعمل كلاس يعمل تنفيذ للانترفيس بستخدم الانيمنس كلاس
         //ملاحظة
         //ما بنقدر ننشئ انستنس من الانترفيس ونهيئه
         //السبب بسيط لانه ما في دوال فيه الها بادي انه نقدر نستدعيها
         //ولكن باستخدام الانيمس بروح الايرور
         //انه نعمل اوفررايد للدالة مباشؤة من خلاله
         /*
         اول شي بنعمل انترفيس وفيه دالة ابستراكت
         تانيا بنروح ع المين ننشئ انستنس من الانترفيس وبنفذ الامانينس انترلوب
         InterfaceName obj= new InterfaceName(){
              @Override
              public void method(){}
         }
         */
         //وممكن نفس اللي قبل ما اعرف ريفرنس هنا من الانترفيس ازا بدي استخدم الدالة مرة واحدة فقط
         /*
         new InterfaceName(){
              @Override
              public void method(){}
         }.method();
         */
         
         
         
         //من مميزات الانانيمس والانترفيس انه بنقدر نستخدم فيهم مصطلح اللمدا اكسبرشن
         //هناك مصطلح اللمدا اكسبرشن==بختصر الكود وبريحنا بالسنتاكس 
         //1- خاص بالانترفيس والانانيمس
         //2- بنستخدمه لما يكون هنا سنجل ميثود فقط
         
         //مثال عملي
         //عرفنا ريفرنس من الانترفيس==InterfaceName obj; /لحتى نطبق عليه اللمدا اكسبرشن
         //بناخد هذا الاوبجكت ومش ضروري نكتب التايب الخاص بالانترفيس اي نيو انترفيس التهيئة
         //بداله بنستخد السينتاكس الخاص باللمدا== obj= () ->{}
         //ومن ثم بالداخل مش بحاجة نكتب اسم الميثود بنكتب البادي الخاصة فيها وخلص
         //وبنرجع ناكد بنستخدمه لما يكون عنا سنجل ميثود
         /*
         InterfaceName obj;
         obj = () ->{ 
             s.o.p(.....);
         }
         */
         //اختصار اكتر للمدا
         //obj = () -> s.o.p(....);
         
         //ملاحظة
         //لو الميثود بتستقبل متغير معين
         //مثلا انتجر
         //obj = (int y) -> s.o.p(....);==بنكتب الانتجر في الحالة العادية لما كتبنا انانيمس انر كلاس
         //لكن في اللمدا ما في داعي نكتب نوع التاي مباشرة المتغير
         //obj = (y) -> s.o.p(....);
         //وللاختصار اكثر في حالة انه بنتعامل مع براميتر واحد
         //obj = y -> s.o.p(....);
         //باللمدا ما في داعي نكتب اسم الدالة
         
         //بالنهاية لما بدنا نطبع تنفيذ الدالة من خلال
         //obj.اسم الدالة();
         
         
         //ملاحظة
         //ما بقدر استخدم مصطلح اللمدا اكسبرشن مع الكلاس
         
         
         
         //الحالة التالتة
         //انه نعرف الانانيمس كلاس as argument for(method / constructor)
         
         //مثال عملي
         //بنعمل انترفيس فيه دالة بتستقبل اوبجكت من الانترفيس
         //في المين
         //بنستعدي الدالة وبنبعت الانانيمس انر كلاس 
         //اللي هو عبارة عن تهيئة الانترفيس والبادي تاع الاوررايد للدالة
         /*
         method( new Interface (){
             @Override
             public void method (){
             s.o.p(...):
         });
         رح نلاحظ هاي الحالة بكثرة لما نستخدم اكواد تطبيقات الموبايل
         */
         
         
         
         
         //60
         //Anonymous Inner Class (Constructor, Extra Methods, Local Variables , Var Keyword)
         //هل ممكن اعرف كونستراكتر داخل الانانيمس
         //هل ممكن اضيف اكسترا ميثود
         //كيف ممكن اتعامل مع اللوكال فاريبل داخل الانانيمس
         //رح ناخد الفار كيبورد داخل الانر
         
         
         
         //1-هل ممكن اعرف كونستراكتر داخل الانانيمس
         //الانر كلاس ما اله اسم فما بقدر انفذ الكونستراكتر داخله
         //ولا بقدر اتعامل برقم هذا الانر مثلا الاول واحد وهكذا
         //ولكن ممكن استفيد من اسم السوبر كلاس للانر
         /*
         مثلا لو عملنا كونستراكتر داخل السوبر كلاس
         اللي بدون باراميتر مثلا رح يتنفذ لما نعمل تنفيذ للانر كلاس مباشرة
         ولو عملنا كونستراكتر ببراميتر وبعتنا براميتر للريفرنس من السوبر وداخله الانر كلاس
         رح ينفذ الكونستراكتر ببراميتر بشكل عادي
         ClassName obj=new ClassName(){
            InnerClass
         }
         ClassName obj=new ClassName(20){==هنا مثلا عملنا كونستراكتر داخل الكلاس بستقبل عدد انتجر
            InnerClass
         }
         كيف تم تنفيذ الكونستراكتر
         ببساطة بما اني معرفة انستنس من الكلاس رح يروح يستدعي الكونستراكتر الخاص فيه
         */
         
         
         //ملاحظة
         //ممكن نحط اناشلايزر بلوك داخل الانانيمس انر كلاس
         //ممكن يكون بديل عن الكونستراكتر
         /*
         {
           s.o.p{...};
         }
         */
         //ملاحظة
         //الاولوية للانشلايزر عن الكونستراكتر
         //لكن في هاي الحالة
         //تنفذ الكونستراكتر للكلاس من خلال الريفرنس بعدين رح يدخل ع الانانيمس وينفذ شو فيه
         //السبب
         //الاولوية اذا كان الانشالايز والكونستراكتر بنفس الكلاس
         //لكن هنا بنتعامل مع كلاسين الاساسي والانانيمس انر كلاس
         
         
         
         //2-هل ممكن اضيف اكسترا ميثود
         //لو دخلنا على الانر وحطينا فيه دالة جديدة ما رح يعطي ايرور
         //ولو حطينا فيلد معينint x=5;مثلا وحطينا في الدالة ما رح يعطي اي ايرور
         //ولكن الخلل
         //لما استخدم اوبجكت الكلاس الاساسي واستدعي هاي الدالة الجديدة ==Erorr
         //لانه هاي الدالة موجودة داخل الانانيمس انر كلاس مش الكلاس الاساسي اللي معموله ريفرنس
         //وما بقدر انشئ اوبجكت من الانانيمس انر كلاس لاني ما بعرف اسمه اساسا
         //الحل
         //انه اضيف هاي الميثود داخل الكلاس الاساسي ايضا لحتى يقدر يتعرف عليها بالمين
        
         //بس لو انا ما بدي اعلن عن هاي الدالة واحطها في السوبر كلاس
         //هان بتيجي فائدة
         //Var Keyword ==مش مدعوم من الاصدار الثامن
         //بحطها في المين بدل اسم كلاس السوبر قبل اسم الاوبجكت
         /*
          var obj=new NameClass(){
               InnerClass
               @Override
               +NewMethod  
         }
         */
         //هيك بقدر استدعي الدالة الجديدة في الانر كلاس اللي مش موجودة بالكلاس الاساسي عن طريق الاوبجكت
         //obj.NemMethod(); ==True
         
         //ملاحظة
         //Var Keyword
         //ظهرت بالاصدار العاشر للجافا وظيفتها تستقبل اي داتا تايب==يريميتف داتا او كلاس تايب
         //رح تعرف نوع البيانات من القيمة المسندة الها
         /*
           var x=2;
           var y="Noura";
           var s='h';
           var n=new ClassName();
         */
         //من خلالها مش محكوم بكلاس تايب معين
         //لانه لو حطيت اسم الكلاس قبل الاوبجكت بصير مقيد بالاوبجكت اني انادي الدوال المعرفة بالكلاس الاساسي فقط
         //اما الدوال الجديدة فالانر ما بقدر استدعيه فلما حطينا فار انحلت المشكلة ٌٌٌٌ
         
         
         //ملاحظة
         //Var Keyword==لكنه بحتوي على بعض القيود
         //1- الفار مش مسموح استخداماas global سواء كنا نتعامل مع متغير عادي او مع انستنس من الكلاس
         /*
         لما عرفنا الفار بالكلاس الخارجي عمل ايرور بس بنستخدمه بالمين
         */
         //2-مش ممكن استخدمهاas genaric type
         /*
         مثال لما قلنا الاري ليس بتستقبل جيناريك تايب سواء انتجر فلوت:ArrayList <Integer> =...etc
         لكن لو استخدما الفار كجينريك رح يعطي ايرور
         ArrayList <var> =...etc ==>Erorr
         */
         //3-ومش ممكن استخدمها مع جيناريك تايب
         //var <Integer> =...etc  ==>Erorr
         //ملاحظة
         //بنفع استخدمها ازا ما كان في جيناريك تايب
         //var List= new ArrayList();
         
         //4-ما بنفع اعرف الفار وما اعطيه قيمة معينة
         //var x; ==Erorr
         //var x=null; ==Erorr لازم اسندله قيمة معينة لازم يعرف شو الداتا تايب المسنود اله
         
         //5-ما بنفع استخدمها كبراميتر لميثود او كاريتيرن تايب لميثود معينة
         //6-ما بقدر استخدمها مع اللمدا اكسبرشن
         
         //-----------
         //ملاحظة
         //لو عرفنا متغير معين خارج السكوب الخاص بالانانيمس كلاس
         //بقدر اوصله داخل الانانيمس كلاس اطبعه مثلا
         //لكن المشكلة لو بدي اعدل عليه داخل الانر
         
         
         //ملاحظة
         //ممكن نعرف الانانيمس انر كلاس داخل اي ميثود عادية
         //ومثلا دخل الانر في ميثود ممكن اعرف كمان انيماس انر كلاس وهكذا
         
         //ملاحظة
         //بما اني ورثت الكلاس الاساسي بقدر استخدم الميمبرز اللي داخله داخل الانانيمس انر كلاس
         //ممكن استخدم الفيلدز اللي داخل الكلاس الاساسي داخل الانانيمس انر كلاس  الفيلدز او الميثود
         //بستخدمها داخل الانر مباشرة باسمها
         
         //ملاحظة
         //مش ممكن اتعامل مع الستاتيك انشلايزر داخل الانانيمس انر كلاس
         //وايضا ازا حاولنا نعرف ميمبر ستاتيك رح يعطي ايرور
         //فقط مسموح اعرف الستاتيك ازا كان فاينل رح تمشي الامور
         //static int x=2; ==Erorr
         //final static int x=2; ==True
         
         //ايضا ما بقدر استخدم دوال ستاتيك داخل الانانيمس انر كلاس 
         
         //---------------------------------------
         //من الدقيقة19
         //مثال عملي 
         //بناء اب معين موجود عدة ازرار ازا ضغطنا على الزر الاول مثلا رح يعطينا اشارة انه ضغطنا عليه وهكذا
         //بدنا انفذه بشكل مبسط باستخدام الانانيمس انر كلاس
         
         //رح نستفيد من الباكج 
         //الخاص بالازرار والخاص بالرسوم والحركة لبناء الواجهة تاعت الازرار يعني
         //import java.awt.FlowLayout;
         //import java.awt.event.ActionEvent;
         //import java.awt.event.ActionListener;
         
         //import javax.swing.JButton;
         //import javax.awt.JFrame;
         //بنلاحظ انه بالتصميم الجرافيكي انا اخدته لحتى نبني واجهة معينة بتم تنفيذ داخلها اوامر معينة
         /*
         الواجهة عبارة عن 
         اولا من خلال الفريم كتبنا عنوان هاي الواجهة
         وقبل هذا عملنا انشلايزر بلوك لحتى يكون اله الاولية ينفذ حجم الواجهة ولونها مثلا
         ثم باستخدام كلاس البوتون انشئنا اربع ازرار وسميناهم داخل الريفرنس للبوتون
         JButton b1=new JButton("Click1");..etc
         وعند كل زر عملنا ايفنت معين انه لما يضغط ع هذا الزر يطلعنا رسالة انه ضغط ع هذا الزر جست
         هذا بشكل عام رح انفذ مستقبل هذا الكلام بشكل عملي
         */
         //استخدمنا الكود بشكل مختصر من خلال الانانيمس ومن خلال اللمدا اكسبرشن
         //فيهم الامور رح تكون اسهل ومختصرة
         
         
         
         //-----------------------
         //61
         // Java Enum (What is Enum, Examples, UML, Enum with switch, Attributes & Methods)
         
         //Enum keyword (Enumerations)
         //بستخدمها مع مجموعة من الثوابت كايام الاسبوع مثلا والباي
         //List of constant variable
         
         //Enum ==special java type to define  collections of constants
         //Enum ==special class لحتى يمثل مجموعة من الثوابت (unchangeable variables ,like final variable)
         //الثوابت تعادل الفاينل فاريبل
         //PI =3.14 , WeekDays ,Months ,country,city,size(small-medium),currency ...etc
          //لنظام محل مثلا الخ ==كل عنصر عبارة عن ثابت او فاينل بالجافا اي لا يمكن تغييره
          
          //UML
          //لما نعرف انم كانه بنتعامل مع كلاس معين
          //بنكتب الاناموريشن وبين الدبل انجل براكيتس بنكتب كلمة اناموريشن
          //example == DayOfWeek وفوقها<<enumeration>>
          //طبعا هي في بوكس وبنسكر عليها بخط وبنكتب تحتيها ايام الاسبوع مثلا
          //اضافة لاي اتربيوتس انا بدي اياها
          
          //ملاحظة
          //هنا ايام الاسبوع مثلا مش اتربيوتس عاديين هم عبارة عن اوبجكتس
          
          //اضافة انه ممكن استفيد من الاناموريشن باي كلاس معين
          //من خلال اني اعرف هذا الانم فيه
          //class :DayOfWeek
          
         //تعريف الانم
         /*
         enum DayOfWeek{
         //بنضيف الثوابت اللي بدنا اياها اللي بدنا اياها تكون فاينل او كونستنت
         //ويفضل تكون او متعارف عليها بين المبرمجين انه جميعها كابيتال لاتر
         //وكل عنصر من الثوابت عبارة عن اوبجكت
         SUTERDAY,SUNDAY,MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY //; ممكن نحطها وممكن لا
         //بس ازا كان في اتربيوتس تانية او دوال الخ لازم نحطها والا ايرور
         } 
         */
         //ملاحظة
         //ممكن نعرف الانم داخل الكلاس او خارج الكلاس يعني يكون في كلاس لحاله
         //بنعمل تنفيذ لكلاس وبنختار انم كلاس الخ
         
         //اول فائدة للانم
         //مثال عملي
         //عملنا الانم في كلاس لحاله سميناه نمبر وداخل المين سويتش
         //استخدمنا قيم انم لحتى تكون مبعوتة للسويتش
         //مش قيمة عادية لحتى تكون الامور اكثر سهولة من ناحية اعادة الاستخدام مثلا في حالة القيمة المبعوتة واحد او تلاتة وتنين ما بتستخدم
         //بنستخدم الانم عشان لو شلنا قيمة التنين منه ببين انه في خطأ في السوتش عند الحالة المبعولتلها تنين 
         //هذا الامر ما فهمته!!!!!!!!!الدقيقة التاسعة
         //ما علينا
         
         /*
         enum Numbers{
           ONE,TWO,THREE
         }
         //ثم في كلاس المين
         Numbers obj=Numbers.بجيبلي كل قيم الكونسيبت; ==استخدمنا هذا السطر بدل ما نعرف القيم فاينل بكزا سطر
         
         switch(obj){....etc}
         */
         //الميزة انه في علاقة بين السويتش وانم انه مباشرة بتتعرف عليها السويتش
         //فالهدف من انم هنا
         //1-انه الكود يكون مفهوم اكثر
         //2-وانه ما يكون عندي اي case ==>useless
         
         //ملاحظة
         //في هاي الحالة كيف وصلنا للقيم مباشرة=== Numbers.بجيبلي كل قيم الكونسيبت;
         //تركيبة النم:
         //كل القيم الكونسبت موجودة في كلاس اسمه باسم الانم(defult)
         //بكون شكلها كالتالي
         /*
         class Numbers{
         public static final Numbers ONE=new Numbers(); //الكلاس رح يمثل الاوبجكت هذا ب==public static final
         public static final Numbers TWO=new Numbers();
         public static final Numbers THREE=new Numbers();
         //اذن هنا يوجد ثلاثة اوبجكت ==new بما انه استخدمنا
         //فاينل وستاتيك وبما انها ستاتيك بوصللها مباشرة من خلال اسمها
         //بدون تعريف اوبجكت بالمين فقط من خلال اسم الكلاس الانم
         */
         
         
         //مثال العملي التاني
         //تم انشاء الانم داخل الكلاس نفسه
         //بنتعامل معه كاي كلاس يعني ممكن نعرف بالانم اتربيوتس اخرى ودوال الخ
         //الثوابت عبارة عن اوبجكت بقدر جنبها استدعي باريماترايز كونستراكتر او نو ارجمنت كونستراكتر
         //من خلال انه نكتب الثوابت وخلص اما ازا بدي استدعي باراميترز معين لازم اكتب كونستراكتر ببراميتر للانم بالتاكيد
         /*
              public class Main {
                enum WeekDays{
               SUTERDAY("Working day"),SUNDAY,MONDAY,TUSEDAY,WEDNSDAY,THURSDAY,FRIDAY("Day off");
               private String s;
               private WeekDays() {
                   }

               WeekDays(String s){
                   this.s=s;
               }
                   public String getS() {
                       return s;
                   }

                   public void setS(String s) {
                       this.s = s;
                   }
               }

               public static void main(String[] args) {
                   System.out.println(WeekDays.SUTERDAY);//SUTERDAY
                   System.out.println(WeekDays.SUTERDAY.getS());//Working day
                   System.out.println(WeekDays.FRIDAY.getS());//Day off
               }

           }
         */
         
         //ملاحظة
         //اي انم بننشئه بعمل وراثة من انم كلاس تاني
         //WeekDays.FRIDAY.بظهرلنا مجموعة من الدوال
         //ctrl+click على الدوال بجينا من وين مصدرهم
         //رح يظهرلنا ابستراكت كلاس بتم نوريثه لاي كلاس انم احنا بننشئه
         //وهذا الكلاس عامل امبليمنتس لاكتر من انترفيس وداخل الكلاس الكثير من الدوال اللي بقدر استفيد منها
         
         //ملاحظة
         //مش مسموح في الانم كلاس انه نورث من كلاس اخر==extends X
         //لكن مسموح نعمل امبليمنتس لانترفيس == implements (True)
         
         //ملاحظة==شكله مش مدعوم هذا الاشي بالاصدار الثامن !
         //بقدر اعرف ابستراكت ميثود  داخل الانم==Abstract Method (true)
         //ولكن لازم اعمللها امبليمنتيشن داخل كل انستنس اي اوبجكت داخل الانم==@Override
         
         //نطبق هذه الملاحظات على الكلاس العملي السابق
         //اضافة الى نعمل دالة ابستراكت ونعمللها تنفيذ بكل الانستانس ومن ثم امر طباعة
         
         
         //ملاحظة بالنهاية
         //انه ممكن الاقي انم كلاس موجودة باللغة وجاهزة
         //Built-in Enum classse in Java
         /*
         بالمختصر من خلال الذهاب الى الديكيومنتيشن الرسمي
         //API decumations
         //All Modules == set of packages designed for reuse.
         //كل باكج عبارة عن مجموعة من الكلاسيز
         //والانترفيس ومجموعة من الانم كلاس والميثود
         
         //وبنلاقي انم كلاسيز جاهزة بنقدر نستفيد منها
         //منها
         //WeekOfDays -month ....etc
         //ما بنحتاج نبرمجها من اول وجديد
         
         //بنستفيد من الانم كلاس من خلال انه نعمل import للكلاسسيز في النت بينز
         //بكون مكتوبjava.net..etc
         
         //بعد ما نكتب الامبورت للكلاس
         //بنقدر نستخدم ونستفيد من الدوال من خلال جمل الطباعة
         //s.o.p(NAMECLASS.method);
         
         */
         
         
         
         //62
         // Java Enum ( Real life example, ordinal, compreTo, toString, name, valueOf, values )
         
         
         //الميثود الموجودة بالسوبر كلاس اللي اي اينم كلاس بننشئه برث من هذا الكلاس
         
         //مثال عملي
         /*
         مطعم وهناك قائمة من الطلبات وكل طلب اله ستيتاس معينة خاصة فيه
         بس بالبداية الستيتس موحدة لجميع الطلبات بيندينج
         بس المفروج بعد هيك تتغير لعملبة التحضير مثلا بعد هيك اذا في توصيل للطلب وبعد هيك اكمال الطلب وبعد هيك في خيار لانه الطلب ينلغي
         
         لحتى تكون هدول الستيتاس مور ريدابل وحتى اضمن انه ما حدا يعبيهم بالطريقة الخاطئة
         رح ننشئ انم ونخزن داخله هدول الستيتس==status
         داخل كلاس خاص بالاوردر
         */
         
         //التطبيق العملي
         /*
         public class Order {
            public enum OrderStatus{
                //انستنس ثابتة مش ممكن نغيرها
                PENDING,
                PREPARING,
                DELIVERING,
                COMPLETED,
                CANCELED;
            }
            //بروباريتي من نفس نوع الانم
            private OrderStatus status;//داخل الستيتس رح اعتمد حالة الطلب الخاصة فينا

            public OrderStatus getStatus() {
                return status;
            }

            public void setStatus(OrderStatus status) {
                this.status = status;
            }
            //دالة بتفحص ازا الطلب في حالة الديليفري رح ترجع ترو والا بفولس
            public boolean isDeliverable(){
                if(getStatus() == status.DELIVERING)
                    return true;
                else
                    return false;
            }

        }
        class Main{
            public static void main(String[]args){
        //اول ما يوصلنا اوردر رح ننشئ اوبجكت لهذا الاوردر
        Order o1=new Order();
        //ملاحظة
        /*
        ممكن الطلب يكون اله كونستراكتر اكيد
        اسم الزبزن رقم التيلفون مكانه والعناصر اللي بده اياهم
        هدول بكونوا على شكل اري
        */
        //بعد ما اجا هذا الاوردر ممكن نعمل تغيير لهذا الاوردر
        //كبداية لهذا الاورد بكون بيندنج
       /*
        o1.setStatus(Order.OrderStatus.DELIVERING);
        System.out.println(o1.isDeliverable());
        
        //ملاحظة بالنهاية
        //متى بقدر اغير الستيتس الخاص بالطلب==setStatus
        //متى تستدعى هذه الميثود
        /*
        بكون في شاشة معروضة عند المحاسب مثلا خاصة بالطلبات 
        وبكون في خانة الستيتس هو بتحكم شو يحط فلما يحط البيلدنج مثلا
        ع طول بتستدعى ميثود السيت ستيتاس....
        //بس هان عنا بنشرح بدون الايفنت اي الاحداث الشرح مباشرة
        */
        
        //ملاحظة
        //كيف الزبون بده يعمل عملية تراكينج لطلبه اي يتبع طلبه
        //ميثود جيت ستيتس هي المسؤولة عن حالة الطلب==getStatus()
        //فبنستدعي هاي الميثود كل ما يجي الزبون يتبع طلبه شو صار فية
        //System.out.println(o1.getStatus());
        //في التطبيقات الحديتة لايف تراكينج
        //بتفتح الشاشة ومباشرة بدون ما تضظغط ع اي بوتن بفرجيك وين طلبك صار
        /*
        بنستخدم تكنيك منهم السوكيت في البرمجة يعني
        ع اساس انه كل ثلاث ثواني او ثانية
        يتم استدعاء هاي الميثود اوتوماتيكيا
        من غير ما الكاستمر يعطي اي امر 
           }
        }
        */
        
        //ملاحظة
        //المفروض الانم كلاس تكون معرفة بجافا فايل منفصل
        //عشان مش كل ما انشئ اوبجكت من الكلاس يروح ينشئلي انم جديد لهذا الكلاس
        //خلص بكفينا انه ننشئ بروباريتي من الانم كلاس داخل الكلاس ==اللي هي ستيتس من نوع الانم كلاس
    
        //------------------------------
        //اي كلاس احنا بنعرفه رح يورث من كلاس اسمه اينم
        //الميثوداللي بتم توريثها مباشرة لاي كلاس انم من السوبر كلاس انم 
         
        //methods
        //1-
        //name ()==بترجع الاسم كفاينل اسم الكونستان
        //2-
        //ordinal()==بعطينا موقع الكونسبت وين موجود ببدا نت زيرو الخ==index//position
        /*
        System.out.println(EnumClass.Constant.ordinal());
        بقدر اصل للدوال عشان الكونستنت عبارة عن اوبجكت للكلاس
        واذا كان النم داخل كلاس بنكتبه بالبداية
        System.out.println(Class.EnumClass.Constant.ordinal());
        */
        //3-
        //compareTo() ==للمقارنة بين الكونستنس بالمواقع==بناء ع الاوردينال الخاص بكل كونستانت
        /*
        اذا كان متساوي بترجع صفر
        اذا مثلا الموقع الاول قارناه بالخامس اذن==0-6=-6 وهكذا
        System.out.println(EnumClass.Constant.compareTo(EnumClass.Constant));
        */
        //4-
        //toString() ==رح ترجع الانستانس لكن على هيئة سترينج
        /*
        System.out.println(EnumClass.Constant == "Constant");//مش ممكن اقارن الكونستانت بالسترينج عشان هيك بستخدم الدالة تو سترينج
        //بترجعلي الكونستانت عل هيئة سترينج عشان اقدر اقارنها
        System.out.println(EnumClass.Constant.toString() == "Constant"); //==true
        */
        //ملاحظة
        //الفرق بين دالة النيم ودالة تو سترينج انه النيم بترجعلي الكونستانت على هيئة فاينل
        
        //5-
        //valueOf() ==ممكن نبعتلها سترينج معين وترجعلنا الكونستانت في الانم الخاص بهذا السترينج
        /*
         System.out.println(EnumClass.valueOf("Constant"));==retarn =CONSTANT
        */
        //6-
        //values() ==بترجعلنا اري من الانم مكتوب بداخلها جميع لاانم
        //ملاحظة: بتفيدنا لما بدنا نعمل لوب معين على عناصر الانم كلاس
        /*
        EnumClass.values();
        //ممكن نطبعهم عن طريف الفور ايتش
        for(EnumClass e: EnumClass.values()){
           s.o.p(e);
        }
        */
        //ملاحظة
        //ممكن نطبع عناصر الانم عن طريق كلاس الاريز بس بنعمله امبورت
        /*
         System.out.println(Arrays.toString(EnumClass.values()));
        //ليش استخدمنا تو سترينج 
        */
        
        //ملاحظ نهائية
        //بنقدر نقارن بين كونستانت والتاني عن طريق ايكوال ايكوال==
        //وبنستغنى على الكوميبر
        /*
        EnumClass obj=EnumClass.constant;
        if(obj == EnumClass.constant){//بنقارن الانستانس اللي عبارة عن الكونستانت بالبروبريتي ايكوال
            
        }
        //وبنقدر نستغني عن دالة ايكواز اللي بتقارن بين اوبجكت واخر اوبجكت
        if(obj equals(EnumClass.constant))
        //او كومبير تو
        //ولكن نستخدم هدول افضل من == بس انها ميزة اضافية
        */
        
        
        
        
        
        
        //63
        //( EnumSet & EnumMap classes, Benefits of Enums, Enums vs Classes
        
        //( EnumSet & EnumMap classes)
        //واحنا بنتعامل مع اي انم بنفذه رح نشوف كلاسين مهمين للبيرفورمانس لما يتم استخدامهم مع الاينم
        /*
        import java.util.EnumSet;
        import java.util.EnumMap;
        */
        
        //EnumSet <ClassEnum> obj;
        //هذا الكلاس بده نوع معين لحظة التعريف
        //بنعطي الريفرنس تايب  نوع الانم كلاس مثلا الويي ديز وبنسمي الاوبجكت دي مثلا
        /*
        هيك الريفرنس فارغ تماما المفروض نعطيه انيشال فاليو ببعض الكونستنت او جميعها 
        //EnumSet <ClassEnum> obj=EnumSet.رح يعطينا جميع الدوال الخاصة بهذا الكلاس;
        //والدوال هاي بتخلينا نقدر نضيف كونستانت من انم معين داخل الريفرنس اللي انا معرفه من الانم سيت
        */
        
        //Methods...==الخاصة بالانم سيت
        //1-of() :بتستقبل كونستانت معين من الانم وبتحطه داخل الريفرنس 
        /*
        //EnumSet <ClassEnum> obj=EnumSet.of(ClassEnum.constant);
           sout(obj);==constant
        //ممكن نحدد انه بدنا اكثر من كونستنت
         EnumSet <ClassEnum> obj=EnumSet.of(ClassEnum.constant,ClassEnum.constant..);
        //ملاحظة
        //لو كررنا الكونستانت نفسه رح يطبع الكونستانت مرة واحدة لانه السيت وظيفتها تشيل اي تكرار موجود
        */
        
        //2-allOf():لو بدي اضيف جميع الكونستانت داخل الريفرنس
        /*
        //EnumSet <ClassEnum> obj=EnumSet.allOf(ClassEnum.class);
        //بنلاحظ انها بتستقبل التايب للانم اللي بدنا نسنده داخل الريفرنس==والانم عبارة عن كلاس
           sout(obj);==رح يطبع جميع عناصر الانم
        */
        
        //3-range() :رح تعطيني من وين لوين من الكونستانت من الانم اي سلسلة معينة من الكونستانت
        /*
        EnumSet <ClassEnum> obj=EnumSet.range(ClassEnum.constant,ClassEnum.constant);
        وازا طبعنا الاوبجكت رح يجيبلي من الكونستنت اللي طلبته لعند الكونستانت التاني 
        */
        
        //ملاحظة
        //ممكن انشئ انم سيت ولكن م بدي اعطيها عناصر مباشرة بدي القيم البدائية نم او ما بدي اعطيه عناصر مباشرة
        //4-noneOf() :بنبعتلها نوع الانماللي هو اسم النم كلاس ودوت كلاس
        /*
        EnumSet <ClassEnum> obj=EnumSet.noneOf(ClassEnum.class);
        //ولو بدي اضيف عناصر مثلا داخل هذا الريفرنس من خلال
        //5-add(): وبنبعتلها الكونستانت اللي بدنا اياه
           obj.add(ClassEnum.constant);
        */
        
        //6-
        //addAll() :هذا ببعتله ليست كاملة او كولكشن مثلا ريفرنس تاني انا حاطة فيه كونستنس الانم كلها
        /*
        obj.addAll(OtherObject==list);
        or
        //obj.addAll(ClassEnum.class);
        */ 
        
        //7-remove() :لحذف كونستانت معين من الانم
        //8-removeAll(): لحذف مجموعة من الكونستانت
        /*
        obj.remove(constant);
        obj.removeAll(obj);
        */
         
        
        
        //---------
        //EnumMap
        //هذا الكلاس ماشي باستراتيجية الماب اي ==key :value
        //بجبرني اتعامل مع جوز==يعني رح نخزن كونستbnانت بالاضافة الى فاليو تخص هذا الكونستانت
        
        //EnumMap <ClassEnum,String> obj=new EnumMap<>(ClassEnum.class);
        //ملاحظة
        //ما رح يتعامل مع البريميتف داتا تايب فقط الاوبجكت داتا تايب
        //EnumMap <ClassEnum, int> ==ERORR
        //EnumMap <ClassEnum, INTEGER> ==TRUE
        
        //Methods...الخاصة بهذا الكلاس
        //1-put() :لحتى نضيف اي كونستانت بدي اياه مع القيمة تاعته
        /*
                 //ClassEnum Key
          obj.put(ClassEnum.constant ,String value);
          sout(obj); =={constant= value} 
        */
        //وفي كثير دوال خاصة بالانم ماب بنلاقيها بالدوكيومنت ==للبحث وقت الحاجة.............
        
        //ملاحظة
        //الفرق بين الانم سيت واللانم ماب==EnumSet  Vs EnumMap classes
        //بنلاحظ انه الانم ماب حجزناه ب==new اما النم سيت لا
        //لانه الانم سيت ابستراكت كلاس ما بصير انشئ منه اوبجكت اما الانم ماب عبارة عن كلاس عادي
        
        
        //-------------
        //Benefits of Enums
        //1-Enum is type-safe:بمعنى ازا عرفنا انستانس من الانم مش ممكن يقبل اي قيمة الا من كلاس انم
        /*
            EnumClass obj="value"; ===ERORR
            EnumClass obj=EnumClass.constant; ===TRUE
        */
        //2-انه ممكن نستخدمه داخل:switch()statement==زي اي نوع داتا تايب اخر
        //3-
        //الهدف من كلاس الانم
        //هي انه نعرف داتا تايب بتخصنا واللي هي بتمثل==(Enumerated Data Type)
        
        
        //Enums vs Classes
        //الانم هو عبارة عن كلاس ممكن انه يحتوي على اتربيوتس او ميثود
        //ولكن العناصر اللي هي الكونستانت رح تكون عبارة عن==public,static,final:اي هاي العناصر مش ممكن نغيرها
        //Enums
        //مش ممكن ننشئ اوبجكت منها اي نستخدم نيو
        //مش ممكن نورث من كلاس اخر
        //ولكن ممكن نعمل امبليمنتس لانترفيس معين==اي ممكن نطبق مفهوم الانترفيس
        
        
        //ملاحظة نهائية
        //كون الانم كلاس انشلايز كلاس
        //ممكن نلاقي المين ميثود داخل كلاس الانم
        
        //enum:كلمة بنستخدمها لننشئ كلاس الانم ونحط فيه الكونستانتس
        //Enum:هذا كلاس يعتبر السوبر كلاس لاي انم انا بنشئه بحيث يورث جميع دواله
        //Enumeration:عبارة عن انترفيس موجود داخل الباكيج جافا دوت يوتيل
        
        
        
        
        //64
        //Exception Handling (Try-catch block, Multi-catch blocks, Union-catch blocks )
        
        //الاكسبشن هو كلاس
        
        //Exception Handling: معالجة الاستثناءات
        //Exception :حدث غير مرغوب فيه او غير متوقع
        //ممكن انه يحصل اثناء الرن تايم ويتسبب ب
        //distrupts the normal flow of the program is instructions
        //اي يتسبب بتعطيل مسار سير البرنامج==crash
        
        //1-
        //مثال عملي
        /*
        اني اكون فاتح برنامج وفجأة يعمل كراش اي يخرج من اللتطبيق
        بدون مبررات هذا سببه انه ممكن يكون ايرور معين او اكسيبشن كان سبب انه التطبيق يعمل اكسبشن او كراش من اجله
        */
        
        
        //Erorr Vs Exception
        //Erorr: مشكلة صعب جدا حلها
        /*
        غالبا بتكون مشكلتها بالريسورسيز امر خارج عن ارادة المبرمج
        مش ممكن يتفاداه 
        مثلا انا عملت تطبيق معين واستخدمت فيه مكتبات وكان في بعض المكتبات لا تدعم بعض المتصفحات
        مثال اخر انع عملت تطبيق وما بشتغل على بعض الاجهزة بسبب انه السعة التخزينية الها ما بتسمح 
        فهان عنا التطبيق ما بشتغل رح يعطيني ايرور...الخ
        */
        //بالنهاية المسؤول عن هاي المشاكل بالعادة البيئة التشغيلية:runtime environment
        //فالمبرمج مش ممكن يعمللها معالجة او يحلها
        //Exception:ممكن انحل هاي المشكلة
        /*
        مسؤولية المبرمجين يحلو هاي الاكسبشن
        //اسباب عن طريقها بحدث اكسبشن معين:
        ممكن اطلب انبت معين اقيد فيه اليوزر مثلا الارقام يكونو انتجر وراح المستخدم دخل استرينج
        هنا رح يحصل استثناء معين المبرمج بحله
        
        اذا المستخدم بده يعمل فتح لملف معين وهو مش موجود 
        
        واحيانا بكون مشاكل بالاتصال بالشبكة يجب المبرمج يحلها
        */
        //الاكسبشن ممكن يكون سببها المستخدم او المبرمج نفسه لكن بالحالتين على المبرمج الحل
        
        
        //2-
        //مثال عملي لاكسبشن معين وكيف احنا نعالجه لحتى ما يأثر على مسار تنفيذ البرنامج
        /*
        int []arr=new int[]{1,2,3};
        System.out.println(arr[5]);==Exciption
        لما نعمل رن للبرنامج رح يطلعلنا اكسبشن من نوع معين بكون معطينا شو هو
        مثلا هنا الاكسبشن نوعه اري اندكس
         java.lang.ArrayIndexOutOfBoundsException
        وبعدها بجيبلنا شو الاكسبشن بالزبط
        المهم لمعالجة هذا الاكسبشن بستخدم نوع الاكسبشن هذا ب
        */
        //ملاحظة
        /*
        عند استخدام اي ميثود مثلا انا استخدمت المين رح ينشئ اوبجكت لهذا الميثود
        وهذا الاوبجكت رح يتم ارساله للرن تايم سيستم اللي من شئنه يستدعي اكسبشن اوبجكت
        اللي من داخله رح ناخد نوع الاكسبشن اللي بناخدها لنعالج الكسبشن
        اضافة لبعض التفاصيل زي معرفة الاكسبشن اللي صار الخ
        */
        
        //Exception Handling:
        /*
        try{
            //هنا الجمل اللي بشك انه يحصل فيها اكسبشن معين
        }catch(){//الكاتش بلوك المسؤول عن عملية المعالجة للاكسبشن
                 //بنبعتله المشكلة اللي حصلت معن اي نوع الاكسبشن
                 //النوع كأنه اكسبشن وبنبعتله اسم
                 
                //في حال حصل اكسبشن ما رح يتوقف تنفيذ البرنامج
                //رح ينفذ ما بداخل الكاتش ويكمل التنفيذ
        }
        */
        //ملاحظة
        //الهدف من تراي وكاتش بلوكس انه يستمر تنفيذ البرنامج بوجود الاكسبشن
        //لانه رح يتم ارسال الخطأ للكاتش بلوك
        //يعني لو في جمل بعد هدول البلوكين رح يتنفذو بشكل عادي وعلى العكس لو في اكسبشن وما كان عندي هدول البلوكين
        //رح يتوقف تنفيذ البرنامج
        
        
        //حل المثال الاعلى هكذا
        /*
            try{
                int []arr=new int[]{1,2,3};
                 System.out.println(arr[5]);        
            }catch(java.lang.ArrayIndexOutOfBoundsException e){
                  System.out.println(e);//e.رح يظهرلي مجموعة من الدوال
                  //e لحالها بستدعي دالة تو سترينج مباشرة===e.toString()
                  //output:
                  //java.lang.ArrayIndexOutOfBoundsException: 5
            }
        */
        
        
        //3-
        //مثال عملي اخر على الاكسبشن
        //عندي اري وبدي اوصل لاندكس معين ولكن الانشال فاليو للاري بنل
        //بنلاحظ انه رح يطلع نوع اخر للكسبشن==java.lang.NullPointerExceptionلما نعمل رن بنعرف نوع الاكسبشن هذا
        
        /*
        int arr[]=null;
        System.out.println(arr[1]);==Exception #java.lang.NullPointerException
        */
        
        //حله
        /*
            try{
            int arr[]=null;
            System.out.println(arr[1]);    
            }catch(java.lang.NullPointerException e){//هذا الخطأ بظهر لما احاول اوصل لقيمة معينة لكن المتغير الها نل
                System.out.println(e);
            }
        */
        //ملاحظة
        //NullPointerException عبارة عن كلاس
        //داخل هذا الباكج: java.lang
        //واي كلاس داخل هذا الباكج ممكن استدعيه مباشرة بدون الحاجة من اعمله امبورت اي ما اكتب اسم هذا الباكج كالتالي
        /*
         catch(NullPointerException e)
        */
        
        //4-
        //مثال عملي لاكسبشن اخر
        //مثلا استخدم دالة بتحول الرقم اللي بنحطه كسترينج لانتجر والمستخدم استخدم كلمة مثلا
        //فهنا اكسبشن لانه الكمة بالاصل سترينج كيف رح يحولها لانتجر
        /*
        int val=Integer.parseInt("String96");==Exception//اكسبشن لانه هاي الدالة بتستقبل رقم بصيغة استرينج:"1"
        //نوع الاكسبشن:  java.lang.NumberFormatException
        System.out.println(val);
        */
        
        //حل الاكسبشن
        /*
        try{
          int val=Integer.parseInt("String96");
          System.out.println(val);    
        }catch( NumberFormatException e){
            System.out.println(e);//java.lang.NumberFormatException: For input string: "String96"
        }
        */
        
        
        //5-
        //مثال عملي اخر
        //متغير موجود فيه قسمة الرقم ع صفر
        /*
        int x=5/0;///exciption ==java.lang.ArithmeticException
        System.out.println(x);
        */
        
        //حل هذا الاكسبشن
        /*
        try{
           int x=5/0;
           System.out.println(x);     
        }catch(ArithmeticException o){
            System.out.println(o);//java.lang.ArithmeticException: / by zero
           //بنلاحظ لما نطبع اوبجكت الاكسبشن ببعتلنا شو الخطأ بالزبط
        }
        */
        
        //ملاحظة
        //بعد سطر الاكسبشن لو كان عندي اكثر من سطر اي داخل التراي بولك هل رح يتنفذو
        //لا اول ما يكون في اكسبشن رح يروح ع الكاتش بلوك مباشرة
        //Debug الدليل من خلال:الديبق عبارة عن تتبع لمسار البرنامج كيف بتبعه الكومبايلر
        /*
        اول اشي بنظغط ع الرقم اللي جنب السطر اي بنحدد السطر اللي بدنا نتبع منه تنفيذ البرنامج
        بنختار السطر اللي بعد تراي وبنظغط كليك يمين ثم
        وبنختار==Debug File
        بطلع عنا سطر فوق بختار ايقونة السهم اللي نازل لتحت بحددلي وين رح يروح الكومبايلر على اي سطر
        //وفي حالة الاكسبشن رح يتجاهل اي سطر بعده مكتوب في التراي ورح يروح ع الكاتش ينفذ شو فيه
        وبالنهاية بنوقف الديبق من الشاشة من خلال زر الايقاف
        */
        
        //ملاحظة
        //ممكن اشك انه فيه هان ممكن يكون اكسبشن ولكن ما بعرف شو نوع الاكسبشن
        //هنا بستخدم نوع الاكسبشن اللي بنفع لاي اكسبشن
        //اللي هو:Exception==البيرنت الخاص بجميع انواع الاكسبشن
        //كل انواع الاكسبشن وارثة منه
        /*
        catch(Exception e){}
        */
        
        //عنا مثال عملي
        //في اتنين اكسبشن واحد انا بعرف نوعه مثلا والتاني لا
        //اللي بعرف نوعه بكتب نوعه واللي لا بكتب اكسبشن بنلاحظ صار عنا
        //Multi-catch blocks
        
        //ولكن ملاحظة اي تراي بلوك رح ينفذ كاتش بلوك وحدة لانه
        //رح يشوف اول اكسبشن وينتقل على الكاتش بلوك تبعها ويكمل التنفيذ للاخر
        //6-
        //ولكن في المثال العملي
        //عملية حسابية في نفس السطر تنين اكسبشن
        //اول اشي استخدمنا اندكس للاري مش موجود وساويناه بقيمة مقسومة ع صفر هي الاكسبشن التاني
        //ولكن المعادلات الحسابية في البرمجة يتم الاسناد من اليمين لليسار فيها
        //اذن رح ينفذ الكاتش تاع اليمين القيمة الي تم اسنادها 
        /*
           try{
            int arr[]=new int[]{1,2,3};
            arr[10]=5/0; //==هنا في اتنين اكسبشن==ولكن رح ياخد بعين الاعتبار الاكسبشن اللي قابله بالاول
           // اللي هو القسمة ع الصفر
            System.out.println(arr[10]);
            
        }catch(ArrayIndexOutOfBoundsException e){
            System.out.println(e);
        }catch(ArithmeticException o){//هذا نوع الاكسبشن تاع القسمة ع الصفر رح ينفذه هو
            System.out.println(o);  
        }
        
        */
        
        //ملاحظة
        //بقدر اوحد انواع الاكسبشن بسطر واحد اي نو حدهم بنفس الاوبجكت
        //هاي الطريقة تسمى ب:Union-catch blocks نزلت بعد الاصدار السابع
        /*
        مثلا التطبيق على المثال الاعلى
        catch(ArrayIndexOutOfBoundsException |ArithmeticException e){
            System.out.println(e);
        بهاي الطريقة ما بنحتاج نعمل الكاتش التانية
        }
        */
        
        //ملاحظة
        //في المثال لو حطينا الكاتش التاني عبارة عن البيرنت الاكسبشن
        //رح ينفذ النوع الموجود مش رح يروح ع كاتش الاكسبشن لانه النوع موجود
        /*
        catch(ArrayIndexOutOfBoundsException |ArithmeticException e){
            System.out.println(e);لو نوع الاكسبشن في هذا الكاتش رح ينفذه هو
        }catch(Exception o){
           System.out.println(o);اما اذا نوع الاكسبشن مش موجود بالكاتش الاول هذا الاكسبشن بتنفذ
        }
        */
        //ملاحظة
        //لو كتبنا كاتش الاكسبشن قبل انواع الاكسبشن==ERORR
        //لانه كلاس الاكسبشن في جميع انواع الاكسبشن اذن مش بحاجة لحتى نعيد استدعاءالانواع التانية من الاكسبشن
        //فالترتيب مهم
        //اي ازا انا عارفة نوع اكسبشن معين مثلا الافضل انه نكتبه بالاول بعدين اكتب المور جينرال
        
        
        //ملاحظة
        //ليش بنحدد نوع الاكسبشن وبنحطه بكاتش بلوك ليش م نستخدم كلاس الاكسبشن مباشرة
        //السبب انه الاكسبشن موجود فيه جميع انواع الاكسبشن بياخد وقت اكبر لحتى يطلع النوع عن ما انا اكتب نوع الاكسبشن واخلص
        //رح تكون الامور ابطئ باستخدامه
        
        
        
        
        
        //65
        //Exception Handling ( Finally Block, Throws Keyword, Checked vs Unchecked Exception
        
        //عنا البلوك الثالث
        //Finally Block
        //يتم استخدامه فقط مع الريسورس مثل الملفات الخ
        //بعملcleanup للكود==مثال:closing a file,closing connection
        
        //مثلا
        //انا اذا حصل اكسبشن في البرنامج بدي الفايل او اي اتصال ينقطع  وا يتوقف عن العمل
        //بستخدم بلوك الفاينلي
        
        
        //ملاحظة
        //بلوك الفاينلي الميزة فيه انه بتنفذ سواء حصل اكسبشن او لا
        //كل تراي بلوك في اله اكثر من كاتش بلوك ولكن اله فاينلي بلوك واحد
        
        
        //ملاحظة==return;
        //لو كتبنا كلمة ريترن مثلا بالكاتش بلوك بوقف تنفيذ البرنامج بعد هيك اي رح يتجاهل اي اسطر بعدها
        //مثلا لو في جمل طباعة ما بطبعها البرنامج الخ
        //ولكن لو كان عنا بلوك الفاينلي رح يتنفذ
        //فبنلاحظ بوجود الريترن والاكسبشن او ما في اكسبشن رح يتنفذ هذا البلوك
        
        //المثال العملي
        /*
        try{
            int arr[]=null;
        System.out.println(arr[1]);    
        }catch(Exception e){
            System.out.println(e);
            return;
        }finally{
            System.out.println("finally block");
        }
        System.out.println("Hi Noura!");
        //output
        /*
        java.lang.NullPointerException
        finally block
        بنلاحظ جملة هاي نورا ما تمت طباعتها بسبب وجود الريترن 
        بينما لما حطينا الفاينلي بلوك تنفذت لانها بتتنفذ بجميع الاحوال
        */
        
        
        //بالنهاية الفائدة الحقيقية للفاينلي بلوك هو انه لو بدي اغلق مصدر معين لحتى ما يصيرله مشاكل
        //سواء بوجود الاكسبشن او لا بدنا نعمله اغلاق بالفاينلي
        //بالنهاية انا بستخدم بلوك الفاينلي لما يكون عندي ريسورسيز ازا ما عندي ما بستخدمه
        
        
        //مثال عملي
        //باكد على انه الفاينلي بتنفذ بجميع الحالات
        /*
         public static int getInt(){
             try{
             return 1;
             }catch(Exception e){
                 return 2;
             }finally{
                 return 3;
             }
         }
          System.out.println(getInt()); ==3
        */
        
        
        //ملاحظة
        //هناك بعض الظروف القاهرة اللي بسببها ممكن ما تتنفذ الفاينلي بلوك
        //1- System.exit();
        /*
        ممكن نكتبها بدل كلمة ريترن
        System.exit(2);==رح يتم الخروج من البرنامج عن طريقه
        بنلاحظ مش رح يتنفذ بلوك الفاينلي
        */
        //2- fatal erorr==بمعنى انه يكون عنا ايرور كبير نوعا ما
        //الايرور من احد اللايبرري او الثيرت باي اللي انا شابكهم ببرنامجي الخ رح ندرسه مستقبلا
       
       
        
        //----------------------------
        //Exception Handling
        //Three exciptino conditions:==ظروف الاستثناء 
        //1-checked exceptions (Compile-time exception)
        /*
        هو عبارة عن اكسبشن الكومبايلر نفسه رح يعمله تشيك 
         اثناء الكومبايلر تايم وانا بكتب الكود الكومبايلر نفسه بنبهني اي اوبجكت انا بعرفه من هذا النوع
        لازم اعمله هاندلينج لانه ممكن يعمل اكسبشن 
        */
        //2-unchecked exceptions (Runtime exception)
        /*
        في هذا النوع الجافا كومبايل ما بنبهني اعمل معالجة
        */
        //3-Erorrs
        /*
        ممكن تكون عبارة عن  
         infinet recarsion,or memory leaks
        */
        
        
        //هدول التلات انواع بلزموني بمصطلح
        //Exception Hierarchy
        //ملاحظة==خارطة مفاهيمية
        /*
        التسلسل الخاص بكلاس اكسبشن 
        كلاس Exception وارث من كلاسThrowable وهو وارث من كلاس obj
         وكلاس الاوبجكت هو الاب الاساسي لاي كلاس بالجافا
        */
        //وهناك كلاس Erorr وارث من كلاسThrowable
        //وهذا كلاس الايرور بوورث عدة كلاسات:IOerorr ,virtualMachinErorr.....etc
        
        //وكلاسThrowable بوورث لعدة كلاسات:RuntimeException ,IoException,SqlException...etc
        //وكل كلاس من هدول مثلا رن تايم اكسبشن بورث كلاسات اخرى==كلاسات انواع الاكسبشن مثلا
        
        //ملاحظة
        //اللي بهمنا من الكلاسات نعرف مين تشيك ومين ان تشيك
        //checked exception:
        /*
           Throwable
           Excepton
           IoException
           SqlException
        ما عدا كلاس الرن تايم اكسبشن منهم ان شيك 
        //هدول الكلاسات لما انشئ منهم اوبجكت الكومبايلر بنبهني اعمل للاوبجكت معالجة
        //لانه نسبة منهم بعمل اكسبشن كونهم بتعاملوا مع ريسورسيز
        */
        //uncheked exception:
        /*
           Erorr
           RuntimeException
           IOerorr
           virtualMachinErorr
        //هدول الكلاسات الكومبايلر ما بلزمني او ما بنبهني اعمللهم معالجة
        */
        
        
        //ملاحظة للمعرفة
        /*
        اروح ع الديكيومنتيشن واروح ع باكج
        java.lang === erorr & Exception classes
        واشوف كلاسات الخاصة بالاكسبشن والكلاسات الخاصة بالايرور
        */
        //هدول الكلاسين عبارة عن سب كلاس لكلاسThrowable
        //في بينهم فروقات==دقيقة 11 محاضرة65
        //1-
        /*
        انواع الاكسبشن تشك وان تشك اكسبشن
        لما الايرور فقط ان تشيك
        */
        //2-
        /*
        الاكسبشن يحدث اثناء الكومبايل تايم او الرن تايم
        اما الايرور فقط في الرن تايم
        */
        //3-
        /*
        يحدث الاكسبشن من الابليكيشن نفسه سواء من المستخدم او المبرمج
        اما سبب الايرور الانفايرمينت اي بيئة التشغيل
        */
        //4-
        /*
        يمكن حل الاكسبشن من خلال بلوك تراي وكاتش
        وممكن حل الايرور باستخدامهم ولكن هاي فكرة سيئة لانه ما رح يكون عنا حل مثالي لنتخلص من الايرور
        */
        
        
        
        
        //مثال عملي..........
        //على التشيك اكسبشن
        /*
         public static void main(String[] args) {
        readFile("");//java.io.FileNotFoundException:  (Result too large)
        readFile("D:\\noura\\noura.txt");//java.io.FileNotFoundException: D:\noura\noura.txt (The system cannot find the file specified)
        /*
        السؤال ليش بعطيني هاي الجملة على الرغم من وجود الفايل؟
        */
        }
        //احد الامثلةالقوية على التشيك اكسبشن  هي الفايل ولما نتعامل معاه==في درس بتحدث عن الفايل بتفاصيله
        /*
        اي فابل انا بنشئه وبحاول افتحه او اقرا منه ممكن انه يتسبب بتشيك اكسبشن 
        فايل نت غاوند اكسبشن الخ 
        */
        //بدنا نعمل دالة عن طريقها نعمل فتح لملف معين
        static void readFile(String filePath){
            //FaileReader reader=new FaileReader(filePath);==Erorr
            /*
            لانه ممكن يكون المصدر للفايل اللي رح نبعته مش موجود
            ممكن في المين استدعي الدالة وابعتلها رابط الملف اللي بدي اياه في كلاس المين
            readFile("رابط الفايل");
            بنلاحظ على الجنب لما بدي اشوف شو الكومبايلر بعطيني ايرور بلاقيه بقترح علي انه اعمل
            try-catchوبردو مقترح علينا نستخدم Throws
            بنلاحظ بختفي الايرور
             */
            /*
            try {
                FileReader reader=new FileReader(filePath);
            //برضه هذا الكلاس ممكن يعمل اكسبشن من نوع نت فاوند اكسبشن عشان هيك بحتاج تراي وكاتش
            } catch (FileNotFoundException ex) {
                //Logger.getLogger(Ex.class.getName()).log(Level.SEVERE, null, ex);==بعدين رح نتعلم اللوجر
                System.out.println(ex);
            }
            */
        
        
         //تكملة المثال العملي بشرح نقاط جديدة
         //يعني بمين جديد ودالة جديدة الخ
            /*
            تاني شغلة هنا فايل وبداخله مذكرة وكتبنا فيها اسمنا مثلا وبدنا البرنامج يقرأ من هذا الفايل شو مكتوب بالمذكرة
         الحل هو   
            بدنا نعمل ريد لهذا الفايل مباشرة عن طريق كلاس FileInputStream
            */
            /*
            static void readFile(String filePath){
            FileInputStream fin=null;//قيمة النل عشان اقدر احط قيمة بعدين
            try {        
                 fin=new FileInputStream(filePath);
            //برضه هذا الكلاس ممكن يعمل اكسبشن من نوع نت فاوند اكسبشن عشان هيك بحتاج تراي وكاتش
            //برضه طلعلي خطأ لازم استخدم تراي وكاتش ونعمل امبورت برضه لهذا الكلاس
            System.out.println("file content: ");
            int r=0;
                try {
                    while((r=fin.read())!=-1){//read==بعمل نوع من الكسبشنIOexception==اذن بحتاج تراي وكاتش
                        System.out.println((char)r);
                    }  
            } catch (IOException ex) {
                    Logger.getLogger(Ex.class.getName()).log(Level.SEVERE, null, ex);
                }
            } catch (FileNotFoundException ex) {
               // Logger.getLogger(Ex.class.getName()).log(Level.SEVERE, null, ex);
                System.out.println(ex);
            }//ملاحظة
            //ملاحظة اي انستانس بعرفه من الفايل بكون عبارة عن==resources
            //واي ريسورس انا بعرفه بدي استخدم معاه فاينلي بلوك لحتى اغلق هذا الريسورس
            finally{
            if(fin !=null){//لو ما حطينا الايف بطلع ايرور في انه نسكر الفايل من خلال الدالة شو مفادها هاي الجملة بصير
            try {
                fin.close();//==هاي الدالة ممكن تعملي اكسبشن من نوعIOexception
            } catch (IOException e) {
               // Logger.getLogger(Ex.class.getName()).log(Level.SEVERE, null, ex);
                System.out.println(e);
               }
              }
           } 
        
            //برضه طلعلي خطأ لازم استخدم تراي وكاتش ونعمل امبورت برضه لهذا الكلاس
             public static void main(String[] args) {
        
              readFile("D:\\noura\\noura.txt");//java.io.FileNotFoundException: D:\noura\noura.txt (The system cannot find the file specified)
                //برضه ظهرلي اكسبشن شو السبب مع انه الفايل موجود؟؟؟
                /*
                المفروض يطبع:
                file content:
                Noura Sharif Hassanin
               }
                */
               /*
            فعليا الفاينلي بلوك انا قادر استغني عنها بعد الاصدار السابع لجافا
            من خلال مفهومtry-with-resources
            بمعنى انا بقدر استخدم تراي لحتى اغلق الريسورس بدل ما استخدم الفاينلي بلوك عن طريق
            اني احجز الريسورس الخاص فينا بداخله
            try(FileInputStream fin=new FileInputStream(filePath);){
            ....}catch{}
            قلي ضيفي كاتش لهذا النوع من الاكسبشن واخترت هذا الخيار!!
            فاي انستانس بتعرف بداخل التراي بنعمله اغلاق تلقائيا
            */
            //ملاحظة
            //ممكن اتعامل مع اكثر من ريسورس مثلا انستانس خاص بالفايل واخر خاص بالنت ورك كونكشن الخ
            //رح يكون بهذا الشكل وتلقائيا بنغلقو هدول الريسورس
            /*
            try(FileInputStream fin=new FileInputStream(filePath); FileInputStream fin2=new FileInputStream(filePath);){
            */
        
            //ملاحظة
            //لما ننشئ ريفرنس للفايل بنلاحظ بعطينا اكسبشن خيار انه نضيف تراي وكاتش
            //والخيار التاني نستخدمthrowsوعندي هناك كلمتين:
            //throw-throws في فرق بينهم
            //لو ضغطنا ع خيارthrowsرح يحط هاي الكلمة بجانب الدالة ريد فايل اللي فيها الريفرانس للفايل
            //بعد هاي الكلمة نوع الاكسبشن اللي ممكن يحصل
            /*
               static void readFile(String filePath) throws FileNotFoundException{
                      FileInputStream fin=new FileInputStream(filePath);==هنا الايرور وبختار ثروز او تراي وكاتش وانا اهترت ثروز
            */
            //بنعمل هذا الخيار لانه احيانا بكون مبرمجين بعرفوا يعملو المعالجة للاكسبشن فبنبهم انه في هنا اكسبشن من نوع كزا
            //عليك تعمل معالج لهذا الاكسبشن فبصير اي مبرمج بستخدم هاي الدالة بعرف انه عليه يعمل معالجة
            //مثلا في المين لو استخدمت هاي الدالة وخلص بعطينا ايرور لازم اعالج الاكسبشن
            /*
             public static void main(String[] args)  {
        
                try {
                    readFile("D:\\noura\\noura.txt");//erorr==بعطيني خيار ثروز للمين او اني استخدم تراي وكاتش
                    //لو اخترت ثروز بكتبها جنب المين ومن ثم نوع الاكسبشن 
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(Ex.class.getName()).log(Level.SEVERE, null, ex);
                }
            }    
            */
            //ملاحظة ممكن يكون عندي اكثر من اكسبشن
            //مثال عملي على القبل
            //الاكسبشن الاول في الريفرنس للفايل والتاني لدالة الريد
            /*
            static void readFile(String filePath) throws FileNotFoundException, IOException{//الاكسبشن الثاني بهذا الشكل بنحطه
            FileInputStream fin=new FileInputStream(filePath);        

             System.out.println("file content: ");
             int r=0;
                     while((r=fin.read())!=-1){//هنا الاكسبشن الثاني وحليناه بخيار ثروز
                         System.out.println((char)r);
                    }  
            */
            //وفي المين بنحط كاتش تاني للاكسبشن الثاني
            /*
              public static void main(String[] args)  {
                try {
                    readFile("D:\\noura\\noura.txt");
                } catch (FileNotFoundException ex) {
                    Logger.getLogger(Ex.class.getName()).log(Level.SEVERE, null, ex);
                } catch (IOException ex) {//هنا كاتش الاكسبشن التاني
                    Logger.getLogger(Ex.class.getName()).log(Level.SEVERE, null, ex);
                }
            //هذا التكنيك بنسميهException Propagation==انتشار الاستثناء
            بمعنى اني انا بستخدم ثروز لنوع اكسبشن وبعالجه بمستوى اخر
            }الهدف من هذه الاستراتيجية اني ما عندي العلم الكافي اني اعالج الاكسبشن اللي عندي فبستخدم ثروز
            عشان اللي بعدي ممكن يكون المبرمج عنده علم يحل هذا الاكسبشن فبعمله تراي كاتش مثلا الخ
            فبالنهاية عن طريق الثروز بعمل بروبجيت اي تمرير لاي شخص بستخدم هاي الدالة
            بصير مجبر يعمل معالجة لهذا النوع من الاكسبشن اللي بعد الثروز
            */
            
            
            
            //بالنهاية عنا مثال عملي
            //دالة بتطبع جملة معينة وبعدين بتستعدي نفسها
            //فالمين انا بستدعي هاي الدالة بلاقيها بتستدعي نفسها الى مالا نهاية لعند ما تطبع عدد كبير وبعد هيك البرنامج بتوقف عن التنفيذ
            //النقطةهي اني بقدر استخدم التراي والكاتش لحل هاي المشكلة؟؟
            /*
                   public static void main(String[]args){
                try{
                   print();
               }catch(Error e){//الكلاس المسؤول عن الايرور وارث من الثروابل زي كلاس الاكسبشن برضه وارث منه
                   System.out.println(e);
               }
                /*
                بنلاقيه كاتبليrajava.lang.StackOverflowError
                بعد ما طبع عدد كبير من الكلمات
                ففعليا باستخدام التراي والكاتش انا عالجت الايرور
                ولكن احنا قلنا لا يمكن معالجة الايرور بالتراي والكاتش نفس الاكسبشن فهنا عنا سيرياس بروبلم
                عرفنا انه هي عبارة عنStackOverflowError
                ولكن فعليا ما حلينا المشكلة عن طريق التراي والكاتش==التراي والكاتش بعالجه مشاكل كلاس الاكسبشن
                فالحل هو اني احل المشكلة عن طريق الكود فبدور على المشكلة اللي هي هنا استدعاء ذاتي للدالة
                وبحلها فالملخص انه بقدر استخدم التراي والكاتش ولكن ما بتحللي المشكلة فالافضل اني ابحث عن الكود المسبب لهاي المشكلة
                */
                /*

                    }
                    static void print(){
                        System.out.println("noura");
                        print();

                    }
                    */
            
            
              
             
                
                
                //66
                //Exception Handling (Throw keyword, Throw vs Throws, Throw&finally,Custom exception)
                //رح نتعلم كيف نعملCustom exceptionخاص فينا:استثناء مخصص
                
                
                //Throw keyword
                /*
                بنستخدمها لما بدنا ننشئCustom exceptionاو Erorrخاص فينا 
                رح نلاقي هاي الكلمة في الدوال او فالبلوك في الكود
                ورح نعمل ثرو لchecked or Unchecked Exception والكاستم اكسبشن اللي بنعمله ممكن يكون تشيكد او ان تشيكد
                */
                
                
                
                //مثال عملي==كلمة throw معunchecked exception
                /*
                //هاي الميثود بتاخد رقم وبتفحصه بعد هيك
                public static void validate(int number){
                   if(number <=0)
                             {
                //System.out.println("The number must be greater than zero");
                //عند شرط معين ممكن اعمل ثرو لاكسبشن معين
                //بدنا نستبدل هاي الجملة بثرو
                       // throw new ArithmeticException();
                //لما استدعينا الدالة واحطيناها رقم اقل من الصفر بالفعل راح اعطانا اكسبشن من نوع ارثيماتيك اكسبشن
                //الفائدة تكمن بأنه اي ثرو انا بستخدمه يفترض اعمله معالجة داخل المكان اللي بستدعيه فيه
                //يعني لما استدعينا الدالة واعطيناها رقم بعمللها تراي وكاتش
                //وبالكاتش حطيت نوع الاكسبشن هذا اعطاني نوع الاكسبشن مباشرة==java.lang.ArithmeticException
                /*
                بس بدي اعرف شو الفائدة من هاي الكلمة ثرو==بالثرو انا بعمل رمي للاكسبشن
                والهدف ازا بدي اعمل كاستم اكسبشن خاص فينا سواء من خلال بناء كلاس خاص فينا
                 او استخدم الباراميترز كونستراكتر لهذا الاوبجكت من كلاس الارثيماتك اكسبشن كالتالي
                */
                       throw new ArithmeticException("The number must be greater than zero");//==هيك بنغير الماسج تاع الاكسبشن
                //لما استدعيت الدالة واعملتلها معالجة بالمين وبعتلها رقم اقل من الصفر كانت النتيجة==java.lang.ArithmeticException: The number must be greater than zero
                //ملاحظة
                //ممكن نعمل ريفرنس للاوبجكت تايب ومن ثم نعمل ثرو للريفرنس او ممكن نعمل ثرور للاوبجكت تايب مباشرة زي السابق
                /*
               ArithmeticException e  =new ArithmeticException("The number must be greater than zero");
               throw e;
            الفرق انه هان بنحتفظ بالقيمة داخل ريفرنس    اما لما نستخدم الاوبجكت تايب مباشرة ما بنحتفظ بالقيمة داخل ريفرنس   
            
                    }
                    else{
                        System.out.println("The number has been entered");
                            }
                        }
                    }
                دالة المين فيها استدعاء للدالة
                public static void main(String[]args){
                        try{
                         validate(-1);//==اللي رح يستقبل الاكسبشن اللي جاي من هاي الدالة اقرب كاتش عليه
                        }catch(ArithmeticException e){//اللي هي هاي الكاتش
                            System.out.println(e);
                        }

                 } 
              */
                
                
              // Throw vs Throws
              //فالبداية ثروز كنا نستخدمها جنب الميثود دليل على انه لازم نعمل هاندل لنوع الاكسبشن
              //بس الملاحظة
              //انه ازا استخدمنا اكسبشن من نوع unchecked Exception اختياري اني استخدمThrows
              //ولكن الاكسبشن من نوع checked Exciptionلازم استخدم Throws
              
              //في المثال العملي الاكسبشن من نوع ارثيماتيك اكسبشن هو ان تشكد اكسبشن فاختياري استخدم كلمة ثروز
              
              //اما لو كان الاكسبشن من نوع تشكيد اكسبشن 
              /*
              ازا استخدمت كلمة throw بعطيني ايرور فالحل لهذا الايرور
             1- اني استخدم كلمة throws واوضح نوع الاكسبشن بعدها==عشان وقت ما استدعي الدالة اعمل تراي وكاتش الها
             2- او اني اعمل تراي وكاتش لكلمة throw مباشرة
              */
             
              //مثال عملي على تشيكد اكسبشن
              //الحل  هو اني استخدم كلمة ثروز وفي المين اعمل تراي وكاتش لما استخدم الدالة 
              //الحل الاول
                /*
               public class Ex {
                    public static void main(String[]args){
                        try {
                            validate(-1);//java.io.FileNotFoundException: The number must be greater than zero
                        } catch (FileNotFoundException ex) {
                            System.out.println(ex);
                        }
                      } 
                    public static void validate(int number) throws FileNotFoundException {
                        if(number <=0)
                        {
                            FileNotFoundException e=new FileNotFoundException("The number must be greater than zero");
                                throw e;
                        }
                        else{
                            System.out.println("The number has been entered");
                        }
                    }
                }
               */
                //الحل الثاني
                /*
                public class Ex {

                    public static void main(String[]args){
                      validate(-1);//java.io.FileNotFoundException: The number must be greater than zero
                      } 

                    public static void validate(int number){
                        if(number <=0)
                        {
                            FileNotFoundException e=new FileNotFoundException("The number must be greater than zero");
                            try {
                                throw e;
                            } catch (FileNotFoundException ex) {
                                System.out.println(ex);
                            }
                        }
                        else{
                            System.out.println("The number has been entered");
                        }
                    }
                }
                */
                
                
                //Throw & finally
                //كيف يعمل البرنامج في حال الفاينلي بلوك وكلمة ثرو؟؟كيف الترتيب رح يكون
                
                //مثال عملي
                /*
                public static void main(String[]args){
                    try{
                      int x=5/0;  
                    }catch(ArithmeticException e){
                        System.out.println(e);
                        throw new ArithmeticException("New Throw");//استخدمنا ثرو لارثيماتك اكسبشن اخر مفاده نيو ثرو
                    }finally{
                        System.out.println("Finally Block");
                    }
                      System.out.println("Hi Noura");
                   //output:
                   /*
                  java.lang.ArithmeticException: / by zero
                  Exception in thread "main" java.lang.ArithmeticException: New Throw
                  Finally Block
                          at ex.Ex.main(Ex.java:25)
                  C:\Users\Almajd-PC\AppData\Local\NetBeans\Cache\8.2\executor-snippets\run.xml:53: Java returned: 1
                  BUILD FAILED (total time: 0 seconds)
                   ولكن في الشرح طلع الناتج الاول نفذ فاينلي بلوك بعدين Throw!!

                   ولكن البرنامج ما كمل تنفيذه==ما طبعHi Noura
                   لاني ما عالجت الاكسبشن اللي جاي من ثرو
                  //الاستاذ ما شرحه وانا ما عرفت احله
                  }
                */
                
                //-------------------------
                //خلاصة:Throw vs Throws
                /*
                Throw==بتيجي داخل ميثود او كونستراكتر 
                Throws==بتيجي مع سيقينيتشار ميثود او كونستراكتور
                */
                
                /*
                Throw==لرمي اكسبشن معين 
                Throws==اما هاي لتوضيح انه في اكسبشن لما تستخدم الدالة لازم تعمل معالجة للاكسبشن
                */
                /*
                Throw==بتنعمل لاكسبشن واحد فقط
                Throws== multiple exceptions
                */
                
                /*
                Throw==دايما متبوعة باوبجكت تايب معين او انستانس 
                Throws==يكفي اسم نوع الاكسبشن كلاس
                */
                
                /*
                Throw==مش ممكن تستخدمPropagate checked exception من تلقاء نفسها
                     //بمعنى انه ازا استخدمت Throw داخلchecked exception ==لازم اعمله معالجةtry-catch
                        try{
                          throw new FileNotFound();
                           ...etc
                        اما لو ما بدي استخدمtry-catchفي نفس المكان لازم اعمل معالجة بطريقةthrows
                Throws==بتقدر تستخدمه من تلقاء نفسها
                */
                
                
               
                
                //هنالك نوعين من الاكسبشن
                //build-in exceptions ==زي الاممثلة اللي قبل كان الاكسبشن اللي استخدمناه اله نوعه واله كلاسات خاصة فيه
                //user-define exceptions==ولكن هنا ممكن احنا نفسنا نبني الاكسبشن 
                
                
                //مثال عملي:على النوع الثاني===custom exception
                //مثلا انا بدي ابني كلاس خاص في انا انشئته ومن ثم اعمله ثرو
                /*
                /*
                class MyException extends Exception{//هناك انواع كتيرة من الاكسبشن السوبر كلاس الها كلاس الاكسبشن فبنورث من هذا الكلاس
                                                    //بدنا نشوف شو موجود داخل كلاس الاكسبشن==بنحدد الكلاس وبنعمل ctrl وبنضغط عليه
                                                    //رح نلاقي مجموعة من الكونستراكتر وحدة نو ارجيمنت والباقي براميتايزر طبعا بنقدر نستفيد منهم
                                                    //بنلاحظ ما في اي ميثود
                                                    //لكن في كلاس الاب لكلاس الاكسبشن اللي هو==throwable
                                                    //بلاقي فيه دالة==getMessage()ازا بستدعيها بتعطيني سبب لااكسبشن==مثلا رسالة انا ببعتها للاوبجكت وعن طريق هاي الدالة بطبعها
                                                    //ودالة==toString() اللي رح تعطيني اضافة لسبب الاكسبشن اسم الكلاس اللي جاي منه 
                                                    //ودالة==printStackTrace() بتحددلي وين حصل بالضبط الاكسبشن وبتعطيني معلومات عنه
                                                    //وغيرهم الكثير من الدوال اللي بتساعدني في عملية التريسينج عن الاكسبشن وين حصل وبتعطيني معلومات عنه

                    //مثلا هنا لما بدي اعمل ثرو للاكسبشن اللي بدي انشئه من هذا الكلاس
                    //بدي امرر مسج
                    MyException(String msg){
                        //بدي امرر هاي المسج للبرميتارز كونستراكتر من كلاس الاكسبشن
                        super(msg);
                    }
                }
                */
                /*
                public class Ex {

                public static void main(String[]args){
                   try{
                      validate(-1); 
                   }catch( ex.MyException e){
                       System.out.println(e);//ex.MyException: The number must be greter than! بعتلنا مسج الاكسبشن
                       //احنا بنعرف ازا بعتنا الاوبجكت لهاي الدالة مباشرة كانا استدعينا دالة==toString
                       //لو استخدمان==getMassege رح يعطينا السبب مباشرة اي الرسالة بدون اسم الكلاس
                       //etc.........
                       //e.setStackTrace();//بطلع الاكسبشن واسم الكلاس والسطر الخ
                       //هاي الميثود بنستخدمها في المكان اللي بحدث فيه الاكسبشن للتتبع يعني
                   }

                  } 

                public static void validate(int number){
                    if(number <=0)
                    {
                        MyException e=new MyException("The number must be greter than!");
                        // System.out.println(e.getMessage());==هنا بتطبعلي الرسالة اللي بعتتها للاوبجكت


                            throw e;
                /*
                هنا لو كتبنا ثرو لحالها رح يعطيني ايرور لانه
                Exception Class===checked exception
                فبحتاج اما اعمل تراي كاتش للترو او استخدم كلمة ثروز
                */
                //طب انا ما بدي الحلين بدي اعمل الكلاس تبعي==uncheked 
                //بسهولة بروح اورث من كلاس ان شيكد مثلا==RuntimeException==مهو وارث من كلاس الاكسبشن فمش هيأثر لما ابدل الوراثة من اكسبشن لرن تايم
                //ورح يختفي الايرور من==throwوهيك بصير رمي للاكسبشن ولما استدعي الدالة لازم اعمللها هاندل 
                /*
                ملاحظة انشأت كلاس الماي اكسبشن تاني تحت وارث من الرن تايم عشان توضيح الشرح
                */
                /*
                    }
                    else{
                        System.out.println("The number has been entered");
                    }
                }
                }
                class MyException extends RuntimeException{

                MyException(String msg){
                    super(msg);
                }

                }
                */
                
                
                
                
                //مثال عملي
                //للتوضيح اكثر للفائدة للكاستم اكسبشن
                //اخر عشر دقايق من فيديو66
                //مثال على البنك مفيد وانه نعمل اكسبشن لو كان خيارنا اقل من صفر واكسبشن لو اكتر من صفر ايضا
                //تم تطبيقه بشكل خارجي
                /*
                public class NoNameBank {
                    private double balance;//رصيد الحساب
                    //دالة الايداع
                    public void deposite(double amount) throws InvalidAmountException{
                        if(amount <= 0){
                            throw new InvalidAmountException(amount +" Is not valid");
                        }
                        //كأنا هنا حاطين==elseازا طلع الشرط غلط رح ينفذ اللي تحت
                        balance=balance+amount;
                    }
                    //دالة السحب
                    public double withdraw(double amount) throws InsufficientFoundsException{
                        if(balance <amount ){
                            throw new InsufficientFoundsException("Insufficient founds");
                        }
                        balance=balance-amount;
                        return amount;
                    }
                    //دالة رح تطبع قيمة البالنس المتبقية
                    public void balanceEnquiry(){
                        System.out.println("current balance = "+balance);
                    }
                    public static void main(String[] args) {
                        try{//اخر خطوة عملناها ضفنا تراي كاتش
                        Scanner in=new Scanner(System.in);
                        //اوبجكت خاص بالعميل اللي من كلاس نو بانك
                        NoNameBank acc1=new NoNameBank();
                        String option="";

                        do{
                            System.out.println("1: DEPSITE");
                            System.out.println("2: WITHDRAW");
                            System.out.println("3: BALANCE ENQUIRY");
                            System.out.println("ENTER OPTION");
                            option =in.next();

                            switch(option){
                                case "1":{
                                    System.out.println("Enter DEPSITE amount");
                                    double amt=in.nextDouble();
                                    acc1.deposite(amt);//==بعمل ايرور الا احط ثروز جنب دالة المين او تراي وكاتش
                                    acc1.balanceEnquiry();
                                    break;
                                }
                                case "2":{
                                    System.out.println("Enter WITHDRAW amount");
                                    double amt=in.nextDouble();
                                    double wd=acc1.withdraw(amt);//==بعمل ايرور الا احط ثروز جنب دالة المين او تراي وكاتش
                                    System.out.println("WITHDRAW amount Is: "+wd);
                                    acc1.balanceEnquiry();
                                    break;
                                }
                                case "3":{
                                    //الخيار الثالث للاستعلام عن الرصيد
                                    acc1.balanceEnquiry();
                                }break;
                                default:
                                    System.out.println("Invalid option");
                            }
                            //بالنهاية بدنا نخيروا ازا كان في عمليات اخرى بده يعملها او لا
                            System.out.println("Do you want to continue (Yes/No)?");
                            option=in.next();
                            //هذا هو الشرط ازا الاجابة بيس رح نعيد ازا لا رح يوقف البرنامج
                        }while(option.equalsIgnoreCase("Yes"));
                       //استخدمنا هاي الدالة عشان المستخدم اذا دخل كلمة يس كابيتل او سمول رح يعطي ترو 

                       //بالنهاية الدوال في هذا البرنامج اكيد رح تعمل اكسبشن اذا تحققت شروطها فالافضل حل لهذا لالاكسبشن
                       //بنعمل تراي لكل الكود اللي في البرنامج ومن ثم كاتش لكل اكسبشن ممكن يحصل
                       //عملنا ثروز مثلا للاكسبشن ولكن طلعلنا الاكسبشن في الناتج لانه ما حليناه
                        }catch(InvalidAmountException e){//للكاستم اكسبشن الاول
                            System.out.println(e.getMessage());
                        }catch(InsufficientFoundsException e){//للثاني
                            System.out.println(e.getMessage());
                        }
                        //واضاف ايضا كاتش اخرى لضمان انه الارقام تكون ارقام صحيحة مش نصوص
                }
                class InvalidAmountException extends Exception{
                    public InvalidAmountException(){
                        super();
                    }
                    public InvalidAmountException(String msg){
                        super(msg);
                    }
                }
                class InsufficientFoundsException extends Exception{
                    public InsufficientFoundsException(){
                        super();
                    }
                    public InsufficientFoundsException(String msg){
                        super(msg);
                    }
                }  
                }
                */
                
                //ملاحظة نهائية
                /*
                اذا كانت البروبلم لوكلي يعني بامكاني احلها بنفسي بدون طرف اخر
                لو بامكاني احل البروبليم  باستخدام الابف مثلا او اي كان
                بضل افضل من استخدامtry-catchواسرع 
                
                بستخدمtry-catch
                لما نكون مش قادرين نحصر المشكلة مثلا استخدم ايف الها ويكون الها اكثر من حالة
                */
         }
     
}
